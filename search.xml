<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[koa源码]]></title>
    <url>%2F2018%2F09%2F27%2Fkoa%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[这个是自己学习的第一份源码，后面抽时间去多看看别人写的npm包，提升自己的各方面能力， 这次就深入学习koa的源码，对于后面学习eggjs的设计、或者自己封装一些东西的时候也会有一定的帮助。 整体架构根据自己的所学，可知整体架构主要分为三部分，context、request、response，context为上下文，连接request和response，相关分析如下： 基本使用12345678const koa = require(&apos;koa&apos;)const app = new koa()app.use(function (ctx, next) &#123;return ctx.body = &apos;xianzai&apos;&#125;)app.listen(3000) Application封装我们在使用的时候先new一个koa对象，生成一个app对象1234567891011121314constructor() &#123;super();this.proxy = false;this.middleware = [];this.subdomainOffset = 2;this.env = process.env.NODE_ENV || &apos;development&apos;;this.context = Object.create(context);this.request = Object.create(request);this.response = Object.create(response);if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect;&#125;&#125; 我们发现，每次new的时候将会生成相关一个Application对象，并且绑定context、request、response等等，同时创建的对象有几个方法，一个是use方法、listen方法 use添加中间件12345678910use(fn) &#123;if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;);if (isGeneratorFunction(fn)) &#123; deprecate(&apos;&apos;); fn = convert(fn);&#125;debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);this.middleware.push(fn);return this;&#125; use方法很简单，就是判断传进来的是不是函数，如果不是直接抛出错误，如果是Generator函数，进行包装，然后推进函数的middleware数组中 listen开启服务，添加端口123456listen(...args) &#123;debug(&apos;listen&apos;);// this.callback返回requestListenerconst server = http.createServer(this.callback());return server.listen(...args);&#125; 创建服务器然后进行监听，这里面this.callback返回创建的监听函数，所以比较核心的就是创建监听函数1234567891011121314callback() &#123;// 创建洋葱模型const fn = compose(this.middleware);// 添加错误监听函数事件if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);// 每次新接口过来调用使用const handleRequest = (req, res) =&gt; &#123; // 创建上下文对象 const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn);&#125;;return handleRequest;&#125; 这个函数返回的是另一个函数的执行，所以当后面有请求过来的时候，就将请求的response和request传入，这个函数会首先创建一个上下文，然后将上下文对象ctx传入并执行handleRequest(ctx, fn)，使用闭包来进行分割主要是将上下文分割清楚。 1234567891011handleRequest(ctx, fnMiddleware) &#123;// 将请求进行转换的方法// 如果中间件为进行处理，则返回404const res = ctx.res;res.statusCode = 404;const onerror = err =&gt; ctx.onerror(err);const handleResponse = () =&gt; respond(ctx);onFinished(res, onerror);return fnMiddleware(ctx).then(handleResponse).catch(onerror);&#125; 我试着将全部步骤组织在一起，形成如下内容：123456789101112131415161718callback() &#123;// 创建洋葱模型const fn = compose(this.middleware);// 添加错误监听函数事件if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);// 每次新接口过来调用使用return (req, res) =&gt; &#123; // 常见上下文对象 const ctx = this.createContext(req, res); res.statusCode = 404; onFinished(res, onerror); fn(ctx).then(() =&gt; respond(ctx)).cathch(err =&gt; ctx.onerror(err)) return this.handleRequest(ctx, fn);&#125;;&#125; 这就是callback函数的全部步骤，但是可能好奇，createContext函数是如何创建上下文的，这个也比较简单，如下 1234567891011121314createContext(req, res) &#123;const context = Object.create(this.context);const request = context.request = Object.create(this.request);const response = context.response = Object.create(this.response);context.app = request.app = response.app = this;context.req = request.req = response.req = req;context.res = request.res = response.res = res;request.ctx = response.ctx = context;request.response = response;response.request = request;context.originalUrl = request.originalUrl = req.url;context.state = &#123;&#125;;return context;&#125; 这时候我们创建的上下文对象的原型继承关系如下 所以这就是整体的架构设计，我们给中间件中传入ctx，中间件就可以通过ctx访问koa对象封装的相关方法，举个例子request中对header的封装：12345678910111213get header() &#123;return this.req.headers;&#125;,/*** Set request header.** @api public*/set header(val) &#123;this.req.headers = val;&#125;, koa洋葱模型1234567891011121314151617181920212223242526272829303132function compose (middleware) &#123;if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)for (const fn of middleware) &#123;if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)&#125;/*** @param &#123;Object&#125; context* @return &#123;Promise&#125;* @api public*/return function (context, next) &#123;// last called middleware #let index = -1return dispatch(0)function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125;&#125;&#125;&#125; ![此处输入图片的描述][1] 相关方法分析整体架构了解完成，这时候我们就来了解下response和request中封装的相关方法 #### response分析给body赋值的操作,支持设置三种格式，string、buffer、stream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849set body(val) &#123;const original = this._body;this._body = val;// no contentif (null == val) &#123; if (!statuses.empty[this.status]) this.status = 204; this.remove(&apos;Content-Type&apos;); this.remove(&apos;Content-Length&apos;); this.remove(&apos;Transfer-Encoding&apos;); return;&#125;// set the statusif (!this._explicitStatus) this.status = 200;// set the content-type only if not yet setconst setType = !this.header[&apos;content-type&apos;];// stringif (&apos;string&apos; == typeof val) &#123; if (setType) this.type = /^\s*&lt;/.test(val) ? &apos;html&apos; : &apos;text&apos;; this.length = Buffer.byteLength(val); return;&#125;// bufferif (Buffer.isBuffer(val)) &#123; if (setType) this.type = &apos;bin&apos;; this.length = val.length; return;&#125;// streamif (&apos;function&apos; == typeof val.pipe) &#123; onFinish(this.res, destroy.bind(null, val)); ensureErrorHandler(val, err =&gt; this.ctx.onerror(err)); // overwriting if (null != original &amp;&amp; original != val) this.remove(&apos;Content-Length&apos;); if (setType) this.type = &apos;bin&apos;; return;&#125;// jsonthis.remove(&apos;Content-Length&apos;);this.type = &apos;json&apos;;&#125;, 重定向的实现123456789101112131415161718192021redirect(url, alt) &#123;// locationif (&apos;back&apos; == url) url = this.ctx.get(&apos;Referrer&apos;) || alt || &apos;/&apos;;// 设置重定向的urlthis.set(&apos;Location&apos;, url);// statusif (!statuses.redirect[this.status]) this.status = 302;// htmlif (this.ctx.accepts(&apos;html&apos;)) &#123; url = escape(url); this.type = &apos;text/html; charset=utf-8&apos;; this.body = `Redirecting to &lt;a href=&quot;$&#123;url&#125;&quot;&gt;$&#123;url&#125;&lt;/a&gt;.`; return;&#125;// textthis.type = &apos;text/plain; charset=utf-8&apos;;this.body = `Redirecting to $&#123;url&#125;.`;&#125;, 了解下中间件的开发： koa-router基本用法12345678910111213var Koa = require(&apos;koa&apos;);var Router = require(&apos;koa-router&apos;);var app = new Koa();var router = new Router();router.get(&apos;/&apos;, (ctx, next) =&gt; &#123;// ctx.router available&#125;);app.use(router.routes()).use(router.allowedMethods()); 基本说明koa-router更多的是对方法的封装，比如生成的对象可以使用get、put、post等等相关方法，最后使用routers方法将绑定到所有方法导出，在app.use()进行绑定即可，在koa-router将整体分为两部分，一部分是Router，另一个为Layer为实际的路由 优秀的代码片段生成一个对象 12345function Router(opts) &#123;if (!(this instanceof Router)) &#123;return new Router(opts);&#125;&#125; 良好的注释代码123456789/*** Match given `path` and return corresponding routes.** @param &#123;String&#125; path* @param &#123;String&#125; method* @returns &#123;Object.&lt;path, pathAndMethod&gt;&#125; returns layers that matched path and* path and method.* @private*/ 返回匹配的路由1234567891011121314151617181920212223242526272829303132333435363738394041424344Router.prototype.routes = Router.prototype.middleware = function () &#123;var router = this;var dispatch = function dispatch(ctx, next) &#123;debug(&apos;%s %s&apos;, ctx.method, ctx.path);var path = router.opts.routerPath || ctx.routerPath || ctx.path;var matched = router.match(path, ctx.method);var layerChain, layer, i;if (ctx.matched) &#123; ctx.matched.push.apply(ctx.matched, matched.path);&#125; else &#123; ctx.matched = matched.path;&#125;ctx.router = router;if (!matched.route) return next();var matchedLayers = matched.pathAndMethodvar mostSpecificLayer = matchedLayers[matchedLayers.length - 1]ctx._matchedRoute = mostSpecificLayer.path;if (mostSpecificLayer.name) &#123; ctx._matchedRouteName = mostSpecificLayer.name;&#125;layerChain = matchedLayers.reduce(function(memo, layer) &#123; memo.push(function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); ctx.params = layer.params(path, ctx.captures, ctx.params); ctx.routerName = layer.name; return next(); &#125;); return memo.concat(layer.stack);&#125;, []);return compose(layerChain)(ctx, next);&#125;;dispatch.router = this;return dispatch;&#125;; 总结总之感觉大神写的代码都很紧凑，并且对于功能点分割和功能的连接点很棒，第一次看源码，也说不出什么高深的话，但确实学到了点东西，后面自己在封装这些功能点的时候，希望也能够像大神一样整齐，灵活]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面进行渲染]]></title>
    <url>%2F2018%2F09%2F01%2Fweb%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[这段时间在学习缓存优化，在进行LS缓存优化的时候，动态插入script标签的时候，代码执行顺序前后会出错，但是代码插入到html中的顺序是正确的，思考了很久，最后发现这是 script的async的影响，但是通过这个过程发现自己对于页面渲染和代码执行顺序还是很模糊啊，一直想研究webkit，这次就做一个先驱吧，先行了解一波web页面是如何渲染出来 输入一个url到页面加载经过哪些步骤 面试经常问道的问题，这个问题可以回答很有深度，涉及的面比较广，但是也可以回答的比较简单，如下： 解析出主机名 DNS查询 TCP连接 HTTP请求 服务器进行响应 客户端进行渲染 客户端进行渲染 这次就了解下客户端如何进行渲染 流程图 白话分析 当浏览器拿到html时候，开始解析html，构建DOM，从上往下，在这个过程中遇见css，如果是内联就开启另一个线程来构建CSSOM（紫色的css），如果是外链的话就会就会开启另一线程进行下载，下载完成后进行构建CSSOM，如果在这个过程中遇见script并且async和defer都为false，这时候就会停止解析html，同时，如果目前还有未下载完成的CSS资源或者现有的css还没有构建完CSSOM，js就会进行等待，直到下载完目前的CSS资源，构建完当前的CSSOM，当CSSOM构建完成之后，通过目前的DOM tree和CSSOS进行一次计算，也就是construct-&gt;rendering tree的过程,这个过程中，如果是第一次进行构建肯定会触发一次reflow/layout,然后浏览器启动另一个线程进行pain -&gt; Graphics API，如果不是第一次构建，则会判断当前新的计算需不需要触发reflow，更新rendering tree，当构建完成，这时候就可以去执行前面阻塞js，在执行js的过程中，js将通过DOM API和CSSOM API进行更改DOM 和CSSOM，按照正常流程就是更改一次进行contruct一次，然后update rendering tree，但是浏览器做了优化，具体的优化在reflow和repaint的介绍中，到js执行完毕，就会继续parse html 构建DOM，重复执行上述过程，这中间的几点总结如下： CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。 JS 阻塞 DOM 解析，但聪明的浏览器会”偷看”DOM，预先下载相关资源。 浏览器遇到 &lt;script&gt;且没有defer或async属性的标签时，会触发页面渲染（构建出rendering tree），因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕再执行脚本。所以这时候CSSOM会阻塞javascript的执行，javascript执行会阻塞DOM的构建 问题 为什么js放到body最后、css放到head中比较好？ 同时将js 和 css放置在一起的时候，js在前面，性能好点为什么？ reflow和repaint 上面页面渲染的过程中，js的执行，或者相关逻辑将会通过不同的方式更改DOM或者CSSOM，在这些过程中浏览器将会根据计算来确定需要进行哪些操作，最为典型的就是reflow和repaint，也是我们能够通过此处进行优化页面的两点。首先谈下自己的理解：不论是正在执行的js或者是css伪类激活等等都是更改CSSOM和DOM两者，然后通过DOM或者CSSOM进行构造形成rendering tree进行渲染，页面展示出来，如果是第一次进行构造rendering tree，将会触发layout进行计算元素位置和几何结构，如果已经存在rendering tree将会根据CSSOM或者DOM的变化，判断是不是需要进行reflow过程（计算节点的位置或者几何结构-部分或者全部），当成功构建rendering tree或者更新rendering tree ，如果第一次将会paint，如果不是第一次将会触发repaint过程，然后将页面展示在浏览器上。 reflow 重新计算文档中元素的位置和几何结构的过程（根据实际分为，部分或者全部） 触发的方法如下： 元素属性的变化 盒模型相关的属性: width，height，margin，display，border，etc 定位属性及浮动相关的属性: top,position,float，etc 改变节点内部文字结构也会触发回流: text-align, overflow, font-size, line-height, vertival-align，etc 调整窗口大小 样式表变动 元素内容变化，尤其是输入控件 dom操作 css伪类激活 计算元素的offsetWidth、offsetHeight、clientWidth、clientHeight、width、height、scrollTop、scrollHeight 浏览器中的执行过程 Recalculate Style：浏览器计算改变过后的样式 Layout：这个过程就是我们说得reflow回流过程 Update Layer Tree：更新Layer Tree Paint：图层的绘制过程 Composite Layers：合并多个图层 repaint 根据rendering tree渲染生成页面 触发的方法如下： 页面中的元素更新样式风格相关的属性时就会触发重绘，如background，color，cursor，visibility，etc 浏览器执行过程如下： Recalculate Style：浏览器计算改变过后的样式 Update Layer Tree：更新Layer Tree Paint：图层的绘制过程 Composite Layers：合并多个图层 浏览器对于reflow的优化 浏览器为了防止我们犯二把多次reflow操作放在循环中而引发浏览器假死，做了一个聪明的小动作。它会收集reflow操作到缓存队列中直到一定的规模或者过了特定的时间，再一次性地flush队列，反馈到render tree中，这样就将多次的reflow操作减少为少量的reflow。如果我们想要在一次reflow过后就获取元素变动过后的值呢？这个时候浏览器为了获取真实的值就不得不立即flush缓存的队列。这些值包括： offsetTop/Left/Width/Height scrollTop/Left/Width/Height clientTop/Left/Width/Height getComputedStyle(), or currentStyle in IE 例如可通过下面两种方式进行测试 12345678910// 浏览器做优化，将多次reflow减少为少量的reflowdocument.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123; var date = new Date(); for (var i = 0; i &lt; 70000; i++) &#123; var tmpNode = document.createElement(&quot;div&quot;); tmpNode.innerHTML = &quot;test&quot; + i; document.body.appendChild(tmpNode); &#125; console.log(new Date() - date);&#125;); 1234567891011// 因为js的操作，浏览器需要每次进行reflow，页面性能差，造成假死document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123; var date = new Date(); for (var i = 0; i &lt; 70000; i++) &#123; var tmpNode = document.createElement(&quot;div&quot;); tmpNode.innerHTML = &quot;test&quot; + i; document.body.offsetHeight; // 获取body的真实值 document.body.appendChild(tmpNode); &#125; console.log(&quot;speed time&quot;, new Date() - date); &#125;); 避免reflow和repaint带来的性能开销 避免使用触发reflow、repaint的css属性 将reflow、repaint的影响范围限制在单独的图层之内 defer和async 首先需要注意，这两个属性都是对具有src属性的script标签有效，对于内联script无效 defer defer表示延迟执行引入的javascript，即就是dom解析到defer属性的script脚本，不会停止解析，等到整个dom解析完毕后，按照defer-script顺序执行，执行完毕后触发DOMContentLoaded事件。 async async表示异步执行引入的script，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 document.createElement 这也就是自己这次遇见的问题，最终发现通过这种方式创建的script默认是异步的，所以来讲，动态创建的script是不会阻塞页面的，如果想要同步进行执行可以将async设置为false,如果使用这种方法创建link标签的话，实际测试chrome是不会阻塞渲染的。 上面两种js执行图解 页面渲染触发的事件 页面在渲染过程会触发很多事件，例如window.onload 等等，还有打开chrome network下面展示的DOMContentLoaded时间和load时间等等，这些到底在页面渲染的哪个时间点执行？下面就是结合浏览器和页面渲染图解来详细探讨一番 DOM API的事件 DOMContentLoaded 加载完页面，解析完所有标签（不包括执行CSS和JS），执行每个同步的script标签中的JS，执行完毕后然后触发。补全表单也是在这个时间点后进行补全 load window.onload: 所有文件包括样式表，图片和其他资源下载完成后触发 readystatechange 通过document.readyState 可以读取当前页面加载状态，会有三个值：①loading：加载 - dom正在加载②interactive互动-文档已被解析，但是诸如图像，样式表和框架之类的子资源仍然在加载③comlete 文档所有资源完成加载，状态表示load即将被触发 beforeunload 用户即将离开或者关闭窗口时候 unload 用户离开页面的时候 页面加载中的时间点 domLoading：这是整个过程的起始时间戳，浏览器即将开始解析第一批收到的 HTML 文档字节。 domInteractive：表示浏览器完成对所有 HTML 的解析并且 DOM 构建完成的时间点。 domContentLoaded：表示 DOM 准备就绪并且没有样式表阻止 JavaScript 执行的时间点，这意味着现在我们可以构建渲染树了。 许多 JavaScript 框架都会等待此事件发生后，才开始执行它们自己的逻辑。因此，浏览器会捕获 EventStart 和 EventEnd 时间戳，让我们能够追踪执行所花费的时间。 domComplete：顾名思义，所有处理完成，并且网页上的所有资源（图像等）都已下载完毕，也就是说，加载转环已停止旋转。 loadEvent：作为每个网页加载的最后一步，浏览器会触发 onload 事件，以便触发额外的应用逻辑。 HTML 规范中规定了每个事件的具体条件：应在何时触发、应满足什么条件等等。对我们而言，我们将重点放在与关键渲染路径有关的几个关键里程碑上： domInteractive 表示 DOM 准备就绪的时间点。 domContentLoaded 一般表示 DOM 和 CSSOM 均准备就绪的时间点。如果没有阻塞解析器的 JavaScript，则 DOMContentLoaded 将在 domInteractive 后立即触发。 domComplete 表示网页及其所有子资源都准备就绪的时间点。 js引擎执行js的过程 js引擎是如何执行我们脚本中的js，这些过程清楚吗？前端一段时间拜读最新的忍者秘籍，当时就感觉这块不是很清楚 直接看这个博文，讲的很棒https://juejin.im/post/5b879a9f6fb9a01a0f24a5e1 参考 图解js执行 - 很棒 页面渲染 - 性能优化 css-、js阻塞DOM渲染 浏览器 渲染,绘制流程及性能优化 浏览器工作原理解析 页面渲染-原理 reflow和replaint引发的性能问题 Chromium网页Graphics Layer Tree创建过程分析 页面生命周期 chrome 工具说明 window.onload vs document.onload]]></content>
      <categories>
        <category>web 前端 优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web性能优化之缓存]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存的分类缓存是一个比较大的知识点，同时也是一个极大提高性能的点，缓存有很多种，常见的有浏览器缓存、服务器缓存、代理服务器缓存、CDN缓存、 http协议 客户端在请求资源的时候是这样的，①客户端读取请求报文，并对报文进行解析，提取url和各种首部②然后查询是否有本地副本，如果没有则去服务器进行下载并且保存在本地③接着会查看副本足够新鲜（新鲜度检测），如果缓存已经失效就会询问服务器是否有更新，服务器就会用新的首部和已缓存的主体来构建一条响应报文，④发送给客户端 web缓存相关知识 根据缓存处理方式，可以将缓存分为两种，一种是强缓存，一种是协商缓存 请求过程 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires或者Cache-Control的header 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以如果缓存命中的话，请求返回的header并不是来自服务器，而是来自之前缓存的header）； 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。（浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。）（强缓存命中过程） 如果强缓存没有命中，浏览器直接从服务器加载资源时，同时更新相关缓存（协商缓存） 服务器决策，返回 302，同时更新相关字段（缓存协商） 服务器决策，返回 200，直接替换相关缓存（缓存协商） 强缓存强缓存主要是响应头采用的Cache-Control和Expires进行控制的，其中Expires是http1.0中定义的，它指定了一个绝对的过期时间，而Cache-Control是http1.1规定的。Cache-Control:max-age定义了一个最大使用期，就是从第一次生成文档到缓存不再生效的合法生存日期。由于Expires是HTTP1.0时代的产物，因此设 计之初就存在着一些缺陷，如果本地时间和服务器时间相差太大，就会导致缓存错乱。这两个字段同时使用的时候Cache-Control的优先级更高一点。这两个字段的效果是类似的，当浏览器请求这个资源的时候，先从缓存中中寻找，找到这个资源后，根据这个资源的第一次请求时间和Cache-Control设定的有效期计算出一个资源的过期时间，然后再拿这个过期时间和当前请求时间进行对比，如果请求时间在过期时间之内，则直接命中缓存，返回200（from cache）否则进行协商缓存（服务器验证） 协商缓存强缓存机制如果检测到缓存失效，就会由服务器确定缓存资源是否可用，这种缓存机制被称之为协商缓存，浏览器在请求的时候会带上if-None-Match（对应缓存中的Etag），或者带上if-Modified-Since（对应缓存头部的Last-Modified）服务器根据请求头上的这两个字段来判断资源是否有效，一旦资源过期，则服务器将会返回新资源到客户端，负责将会返回304，客户端直接使用本地缓存，从而保证资源的有效性（如果本地缓存中header没有Etag、Last-Modified则不会进行如此步骤，直接返回200） 要注意，响应头同时存在if-None-Match(Etag)和if-Modified-Since(Last-Modified)的时候，服务器会首先对Etag进行对比，其后才是对Last-Modified进行对比 普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，具体相关规则请查看用户行为对缓存的影响 相关参数 Expires 该字段是http1.0规范，值为一个GMT格式的时间字符串，因为这个值是一个绝对时间，当用户本地时间和服务器时间相差比较大的时候会导致缓存混乱，需要和Last-Modified结合使用 Cache-Cache max-age： 指定设置缓存的最大的有效时间，单位为秒 s-maxage： 同max-age，只用于共享缓存（比如CDN缓存）。 no-cache：设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间 no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 must-revalidate： 告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。 Etag 根据实体内容生成一段hash字符串，表示资源状态，由服务器产生，浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下： 解决使用Last-Modified存在的一些问题 a、某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 b、如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒 c、一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。 Date：Date头域表示消息发送的时间，缓存在评估响应的新鲜度时要用到。 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 缓存失效时间的计算 修正收到时间：corrected_received_age = max(now - date_value, age_value) 资源存活时间：corrected_initial_age = corrected_received_age+ (now - request_time) 资源有效期： 如果有max-age freshness_lifetime = max_age_value 如果有expires freshness_lifetime = expires_value - date_value // 上文提到的 Date 头 两者都没有的话 freshness_lifetime = (now - last_modified_value) * fraction fraction 是一个不大于一的数，通常会设为 10%，也就是说一个资源距离上一次更新有 10 天的话，那么它的缓存时间就是 1 天（10 * 10%），只要资源存活时间在一天之内那么它就是没有过期的。 对比资源存活时间和资源有效期就可以得到资源是否过期 用户行为对缓存的影响 用户操作 Expires/Cache-Control Last-Modied/Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 新开窗口 有效 有效 前进回退 有效 有效 F5刷新 无效 有效 Ctrl+F5强制刷新 无效 无效 from disk cache和from memory cache 因为chrome在高版本中更新了缓存策略，所以有两种缓存方式，分别是from disk cache（磁盘缓存）和from memory cache（内存缓存） 性能优化点 配置超长时间的本地缓存—节省带宽，提高性能 采用内容摘要作为缓存更新依据—精确的缓存控制静态资源 CDN部署—优化网络请求 资源发布路径实现非覆盖式发布—平滑升级 nginx配置缓存 推荐使用Varnish做缓存服务器 源服务器进行设置 源服务器就是拥有真正静态文件或者动态生成HTML的服务器，它有两个职责①请求提供静态和动态内容②通过http缓存头决定如何进行缓存 1234567891011121314151617181920212223# 仅仅是实例，可以根据项目需求自己进行设计location ~* \.(?:manifest|appcache|html?|xml|json)$ &#123; expires -1; # access_log logs/static.log; # I don&apos;t usually include a static log&#125;location ~* \.(?:rss|atom)$ &#123; expires 1h; add_header Cache-Control &quot;public&quot;;&#125;location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ &#123; expires 1M; access_log off; add_header Cache-Control &quot;public&quot;;&#125;location ~* \.(?:css|js)$ &#123; expires 1y; access_log off; add_header Cache-Control &quot;public&quot;;&#125; 缓存服务器进行设置（暂时不接触） 参考文档 强缓存和协商缓存 - sf.gg 腾讯相关实践 - 腾讯官方网站 前端工程化部署 -知乎 nginx缓存最佳实践 - 简书 http缓存 - MDN http缓存失效计算 -]]></content>
      <categories>
        <category>web 前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端的存储三种方式]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8md%2F</url>
    <content type="text"><![CDATA[最近做项目遇见权限控制，主要使用了缓存来记录用户权限，后面有时间整理下了前端的几种存储方式，主要有 cookie、storage cookie属性选项 expires和Max-Age cookie失效时间，为GMT格式，通过new Date().toUTCString()获取，如果没有显式设置，则称之为会话cookie，在浏览器关闭的时候清除 domain和path domain为域名，path为路径，两者加起来构成url，domain和path一起限制cookie能被那些url访问，首先判断的是domain，如果没有设置这两个值，将会使用默认值，domain设置为该cookie的网页所在的域名，path默认为该cookie所在的目录 secure 用来设置cookie只有在确定的安全请求才能发出去，当请求是https或者其他安全协议的时候，包含secure的请求才能发送至服务器，如果想在客户端通过js设置secure的cookie的时候，必须保证网页在https的协议下，在http协议的网页是不能设置成功的 httpOnly 这个设置是设置的cookie能否通过js进行访问，这个设置只能在服务器端进行设置，为了保证安全，可以有效防止xss攻击 如何设置cookie？服务器端进行设置 服务通过response header 中的Set-Cookie进行设置，如果需要设置多个cookie，需要分别设置多个Set-Cookie,通过服务器可以设置 expires、domain、path、secure、HttpOnly 客户端进行设置 通过document.cookie进行设置，同样设置多个cookie需要重复执行document.cookie，通过js可以设置 expires、domain、path、secure（需要在https才可设置成功） document.cookie=&quot;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;; cookie进行编码 cookie其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码，一般会用escape进行编码，读取时用unescape进行解码；可以尝试escape(‘哈哈，genluo’)输出什么 注意 只有当domain、path、name都相同的cookie才能覆盖 domain设置带点的时候，任何 subdomain 都可以访问，包括父 domain，当不带点的时候，只有完全一样的域名才能访问 当通过ip进行访问的时候，domain为当前ip locaStorage特点 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 存储的信息在同一域中是共享的。 当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。 大小：据说是5M（跟浏览器厂商有关系） 在非IE下的浏览中可以本地打开。IE浏览器要在服务器中打开。 localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage受同源策略的限制 方法 window.localStorage.setItem(key, value) window.localStorage.getItem(key,value) window.localStorage.removeItem(key) window.localStorage.clear() window.localStorage 遍历可以使用 事件storage当storage发生改变的时候进行触发，事件的回调函数中有一个参数是event，提供了一些实用属性，例如key、oldValue、newValue、uurl/uri sessionStorage特点 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁，或者在新窗口打开同源的另一个页面，sessionStorage也是没有的。 共享比localStorage更加严格，不仅要求协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下 sf.gg总结的前端发存储 其他的几种存储（不常用） Web Sql Database因为web标准已经放弃此种方式，所以不做深入讨论 indexedDBindexDB 掘金html5 进阶 - indexedDB]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生活随笔]]></title>
    <url>%2F2018%2F08%2F27%2Ftoc-%20%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[做这个博客为的就是在我大学生活期间做一个记录，不论是生活还是敲代码，这个博客在第一篇文章发送一周以前开始搭建，使用时HEXO和GITHUB，让我加粗装个B，当时因为总是出错而且不知道是哪里的问题，就一直拖着，但是心里一直想搭建这个博客，或者说想装这个B吧，哈哈，所以在周五的时候又开始从头再来，这次幸好没出事，成功搭建，目前功能的话只有一个查询，其他的统计、评论有时间或者有必要的时候再看看把这些功能都加上。其实在搭建成功的时候，就想将自己遇见的问题整理下，作为自己的入坑历史，（恩恩，语气是这样，我在对自己说，哈哈，别介意）但是中间有考试，要补各种实验，等等，一直没有时间做这件事情。但是现在的我做完了，一身轻松，感觉好爽，这段时间，可能也就今天吧我比较轻松，能够有点时间写一篇日记，记录一下自己这几天干的什么，计划下一周要做的一些事情和一些感悟吧 这几天干了什么 用最进学到的js相关知识，做了一个下拉菜单，感觉越来越喜欢js了 将网页设计与开发的所有试验外带实验报告都做完了 考了半期高数，形式与政策，半期英语 计划最近 时间将近16周，这段时间开始做c++的半期考核，感觉会好费时间 勤奋峰那边好久没写周报，突然想起来自己忘了 这周有网页的相关期末考试，该复习了 想做技能树，感觉这也是让我知识系统化的一个东西，最近就开始做吧 马上要积极分子选推了，明天后天做两天志愿，还差3个小时，跟着班里面做吧，运气好，碰到了 这周有时间继续再看DOM和BOM，这一学期计划是掌握好js和学点jQ 基本就是这些了 感悟 最有感悟的就是事情不要拖，越拖越多，记住事情都要做，有时间就赶紧做吧 我感觉我要注意下形象了，搞好个人卫生，最近这狗粮一波接着一波的，撑死了 感觉和辅导员闹得不是很愉快，要不要也拍拍马屁，好像不是我的作风 一直想为自己添加的标签就是稳重、沉着、不卑不亢、勤奋，一直努力达到 要和家里人多联系，感觉有一天我真的有事情，不论是哪方面的，家人都是我坚强下去的后盾。 今天和老妈聊天聊得我挺伤心的，老妈一直说着给我囔囔儿子邮点吃的，总怕我吃不好，昨天忘了给老妈大电话，今天老妈给我打电话，语气没有生气，更多是无奈和担心，我就算在忙，也是为了我家里人，如果有一天让我在家人和我拥有的全部里面做出选择，我肯定会毫不犹豫的选择家人，老妈，如果今年暑假你说想我，我不论有多忙，有多少事情，什么事情我都不干了，专门回去陪你，说到做到。 作为第一篇记录生活的文章，值得纪念，坚持下去，李根。]]></content>
      <categories>
        <category>记录生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-观察者模式（Observer和Pub/Sub）]]></title>
    <url>%2F2018%2F08%2F27%2FObserver%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Observer模式个人见解主要分为观察者和目标者，这个模式就是通过一种方式给一个目标者绑定观察者，然后可以通过一种方式，在需要的时候，将一些参数一次传递给目标者的所有观察者（模拟通知）。 一般的主要构成Subject（目标）作为观察者和具体怒表之间的中间存在，主要是方便添加或者删除观察者Observer（观察者）为那些在目标状态发生改变时需获得通知的对象提供一个更新接口ConcreteSubject（具体目标状态发生改变时，向Observer发出通知，储存ConcreteObserver的状态。ConcreteObserver（具体观察者）储存一个指向ConcreteSubject的引用，实现Observer的更新接口，以使自身状态与目标的状态保持一致。 具体实现过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&apos;use strict&apos;;//构造后面存放观察者的一个数组，并且定义很多对应的方法function ObserverList()&#123; this.observerlist = [];&#125;//观察者添加ObserverList.prototype.Add = function(obj)&#123; return this.observerlist.push(obj);&#125;//将观察者清空ObserverList.prototype.Empty = function()&#123; this.observerlist = [];&#125;//得到观察者的数量ObserverList.prototype.Count = function()&#123; return this.observerlist.length;&#125;//得到观察者中具体的某一个ObserverList.prototype.Get = function(index)&#123; return this.observerlist[index];&#125;//将一个观察者插入到index位置ObserverList.prototype.Insert = function(obj,index)&#123; var pointer = -1; if(index === 0)&#123; this.observerlist.unshift(obj); pointer = index; &#125;else if(index === this.observerlist.length)&#123; this.observerlist.push(obj); pointer = index; &#125; return pointer;&#125;;//检索此观察者是列表中的第几项ObserverList.prototype.Indexof = = function(obj,startIndex)&#123; var i = startIndex,pointer = -1; while( i&lt;this.observerlist.length)&#123; if(this.observerlist === obj)&#123; pointer = i; &#125; i++; &#125; return pointer;&#125;//移出第几个观察者ObserverList.prototype.RemoveIndexOf = function(index)&#123; if(index === 0)&#123; this.observerlist.shift(); &#125;else if(index === this.observerlist.length - 1)&#123; this.observerlist.pop(); &#125;&#125;;//后面会使用这个函数将一个对象（objectt）的方法全部绑定到一个对象（extension）中，但是不会保存该对象（object）的中的数据function extend(obj,extension)&#123; for(var key in obj)&#123; extension[key] = obj[key]; &#125;&#125;//构建中间变量function Subject()&#123; this.observers = new ObserverList();&#125;//在自己的observers中添加一个观察者Subject.prototype.AddObserver = function(observer)&#123; this.observers.Add(observer);&#125;//在自己的observers中移除某一个观察者Subject.prototype.RemoveObserver = function(observer)&#123; this.observers.RemoveIndexOf(this.observers.Indexof(observer,0));&#125;//将一条消息传递给所以绑定的观察者Subject.prototype.Notify = function(context)&#123; var observerCount = this.observers.Count(); for( var i = 0;i&lt;observerCount;i++)&#123; this.observers.Get(i).Updata(context); &#125;&#125;//定义的观察者类型function observer()&#123; this.Updata = function(context)&#123; //... &#125;&#125; 缺点缺点有三 实现方式不够直观，采用常用的编程实现方法，没有js的特色在里面。 通知的时候传递参数不够灵活，不能实现仅仅通知对应几个观察者，这种必须全部通知 没有实现目标者和通知者的松散耦合。 Publish/Subscribe（发布/订阅）个人见解这种方式是使用了一个主题/事件通道，在js里面可以使用自定义事件实现，也可以使用 {topic1:[{token:token,func:func},{token:token,func:func}],topic2:{[token:token,func:func],[12345678910### 主要构成**publish**发布广播事件，包含特定的topic名称和参数（传递的数据）**subscribe**添加订阅topic和对应的触发执行函数**unsubscribe**基于topic和token取消订阅### 具体实现 var pubsub = {};(function(q){ var topics = {}, subUid = -1;//为了判断当前有多少执行函数，最后为token进行赋值 q.publish = function(topic,args){ if(!topics[topic]){ return; } //这个topic下面的所有订阅者 var subscribers = topics[topic]; var len = subscribers.length | 0; while(len–){ subscribers[len].func(topic,args); } } q.subscribe = function(topic,func){ if(!topics[topic]){ topics[topic] = []; } var token = (++subUid).toString();//更好实践，下面使用绝对（===）判断 topics[topic].push({ token:token, func:func }); return token; } q.unsubscribe = function(token){ for(var m in topics){ if(topics[m]){ for(var i = 0,j = topics[m].length;i&lt;len;i++){ if(topics[m][i].token === token){ topics[m].splice(i,1); return token; } } } } }})(pubsub)//为了让这种方法更加具有针对性，我们可以使用Object.assign(target,sources1,sources2···)将sources的所有可枚举属性全部赋值到目标对象，这个将返回一个目标对象(也会修改原对象) eg：var person1 = {};Object.assign(person1,pubsub);person1.subscribe(‘text’,function(){ console.log(“接受到text信息”);})person1.publish(‘text’);//输出“接受到text信息”//但是同样适用pubsub(‘text’);同样也会输出：“接受到text信息”，进行下面的思考 `但是如果我创建person1，person2两个对象，他们分别有自己对应的“text”的监听函数，使用上面的那种方法当publish的时候会将其他的对象中的‘text’监听函数触发，解决方法： 可以在给两个分别命名为text1、text2，然后分别添加对应的处理函数 可以新建一个构造函数，将this.topics赋值给对应的新对象，在构造函数的原型上添加对应的topic处理函数，但是这种方式没有封装性，想想还是有点遗憾。与上面Observer模式进行对比，这种方式可以实现多种类/多主题的观察者。 相关的库watch.jswatch.js可以看看这个看似简单的模式的代码如何超过800行]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文的图片问题]]></title>
    <url>%2F2018%2F08%2F27%2Fmd%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[现在编辑博客很不爽的就是编辑的博文不能够插入图片，因为最终将博文上传到博客时，在本地插入的图片不会跟着博文一起上传到图片，所以为了解决这个问题，我从今天晚上开始找方法试着便捷插入图片并且将之显示在我的博文上。 （一） 上传图片获得链接，然后在markdown中引用链接 很便捷的立即找到一个上传图片获得链接的网站 图片上传测试如下： 在自带的markown上面有图片上传，在插入图片时发现的。测试时发现要收钱！ 找到一个新的网站，应该是专门进行图片上传的网站。上传工具测试如下： 看来这个网站很棒，并且支持绑定到七牛云空间 这种方式缺点： 图片管理不是很方便，最后一个网站不错。 这些操作很麻烦 （二）使用HEXO的一种插件 找到一个网站，详细讲使用插件来给自己的hexo来插入图片 我认为就是在_posts同级文件夹下建立一个做上传图片的地址，然后在上传的时候一并上传。 在使用hexo-g的时候自动转化成正确的引用地址。 这个感觉很棒。 具体网站博文：http://www.jianshu.com/p/c2ba9533088a测试效果： 看不懂，失败了。-_-！尴尬 （三）使用七牛图床加其他脚本上传 七牛上传图片的集中方法 分别给极简图床和chorme绑定上快捷拖入上传 测试： 就先这样吧，以后有需要在尝试其他方法。]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近做一个表单验证，以前表单验证所用到的正则表达式都是百度上面找的，这几天有点时间就将学习下，因为内容很多，我感觉我记不住，就将看到的博文整理下，作为自己以后使用正则表达式的参考。 参考博文：30分钟入门教程 | 深入了解正则表达式 | js中的正则表达式 正则表达式验证网站：验证表达式因为我是编写javascript要使用正则表达式，所以从js方面来整理一些语法和注意事项 正则表达式基础语法 常用元字符 ( [ { \ ^ $ | ) ? * + . 代码 说明 \b 匹配一个单词的开始或者结束 \d 匹配数字 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 ^ 字符串的开始 $ 字符串的结束 ^cat 匹配以cat开头的字符串（上面^的应用） cat\$ 匹配以cat结尾的字符串上面\$的应用 代码 说明 \t 制表符 \n 制表符 \r 回车符 \f 换页符 \a alert字符 \e escape字符 \cX 与X相对应的控制字符 \b 与回退字符 \v 垂直制表符 \0 空字符 反义 代码 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开始或者结束的位置 [^x] 匹配除了x意外的任意字符 [^sad] 匹配除了sad这几个字母意外的任意字符 字符转义 如果你想查找元字符本身的话,比如查找*，这时就会出现问题：没有办法指定他们意思。这时就得使用\来取消这些字符的特殊意义。比如使用\*来查找这个\。 重复 代码 说明 * 重复0次或者更多次 + 重复一次或更多次 ？ 重复0次或者一次 {n} 重复n次 {n，} 重复n次或者更多次 {n，m} 重复n到m次 字符类 这个是为了解决匹配没有预定义元字符的字符集合用法，只需要在[]里面列出需要匹配的字符 分支条件 这个指的是有几种规则，如果满足其中任意一种规则都应该匹配用法:使用|把不同的规则分隔开。例如：gray|grey 或者 gr(a|e)y 0\d{2}-(\d|\d{2})和0\d{2}-(\d{2}|\d)匹配的都是有区别的，后面会从正则表达式原理进行分析 分组 这个能够解决重复多个特定字符或者多个正则表达式规则用法：（）指定子表达式，然后对子表达式进行操作分组分为4种类型 捕获型 - （） 非捕获型 - （？：） 正向前瞻性 - （？=） 反向前瞻性 - （？！） 候选 一个分组中，可以有多个候选表达式，用|分隔：例如：gr(e|a|c|s)y这个可以匹配grey，gray，grcy，grsy这种称之为候选 捕获型的后向引用 使用小括号指定一个表达式后，匹配这个字表达式的文本（也就是此分组捕获的内容）可以在表达式或其他程序中做进一步处理。默认情况:，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推… 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权 具体的分组细节可参考js中的分组 后向引用就是用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本，注意如果编号跨界了，就会被当成普通的表达式。 常用分组语法 代码 说明 (exp) 捕获exp，并捕获文本到自动命名的组里 (?:exp) 匹配exp，但是并不给此分组分配组号 正则表达式中还有一些分组命名的语法，但是在js中不支持，所以没有整理 零宽断言 零宽断言，所谓断言就是说它们像\b,^,$用来指定一个位置，所谓零宽就是不会占用任何字符进行匹配。分为4种 零宽度正预测先行断言 - （？=exp） 零宽度正回顾后发断言 - （？&lt;=exp） 零宽度负预测先行断言 - （？！ exp） 零宽度负回顾后发断言 - （？&lt;!exp） 零宽度可以使用一个例子进行说明\b\wq[^u]\w\b匹配包含后面不是字母u的单词但是它会匹配hgjhgq,ds因为[^u]消耗了q后面所跟的字符使用零宽度负预测先行断言就不会出现上面那种情况可将上面那个改写为\b\wq(?!u)\w\b这样就不会出现上面的那种情况 贪婪与懒惰 贪婪匹配当正则表达式包含能够接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配极可能多的字符。懒惰匹配与之相反，是尽可能匹配最少的字符串用法：只要在它们后面加上一个？。这样就意味着是 正则表达式原理分析 工作机制 回溯例子1（分支角度）：0\d{2}-(\d|\d{2})和0\d{2}-(\d{2}|\d)匹配的都是有区别的当匹配前面的字符到（\d\d{2}），首先是进入\d分支，当\d分支匹配完成以后，此时程序会在匹配成功完成之后的位置后面做一个标记，表示在这里进行了一次成功匹配，但程序并没有到此结束，如果后面加着一个全局参数，依然使用这个分支往后匹配，很显然，整个字符串没有能够匹配的字符串模式，然后返回到前面提到的标记位置，从标志位置进行另一个分支的匹配，这个过程就称之为回溯。只要正则表达式没有尝试完所有的可能选项，他就会回溯到最近的决策点，依次循环。这是我们可以确定上面那个正则表达式永远不能匹配到两一个分支内容。例子2（量词角度）：“AB1111BA1111BA” | AB[\s\S]+BA首先匹配AB，贪婪模式的匹配，它会一口吞掉后面所有的字符，也就是后面的字符不用看直接全部匹配，而往后面看，正则表达式后面患有字符B，所以程序会回溯带倒数第一个字符，匹配看是否为B，显然倒数第一个字符不是B，所以他接着回溯，找到字母B后就不继续进行回溯，而是往后面继续进行匹配，程序发现B后面紧跟的字符是A，那么此时匹配结束。但是，如果第一次匹配到的B后面不是A则会进行什么操作。 123456A 匹配第一个字符AB 匹配第二个字符AB1111BA1111BA 贪婪模式下的吞并所有字符AB1111BA1111BA 准备回溯匹配字符B（从上面字符串的最后进行回溯）AB1111BA1111B 找到字符B AB1111BA1111BA 继续匹配A（如果B后面不会A，程序怎么运行？） 通过这个例子，来理解懒惰模式下的匹配过程 12345678A 匹配第一个字符AB 匹配第二个字符AB [\s\S]+匹配到的字符串 AB1 懒惰模式从第一个进行匹配BAB11 不是B，回溯，匹配... AB1111B 找到B之后，继续匹配AAB1111BA 找到字符A，匹配完成，停止匹配 对于上面提到两个问题，答案就在上面的那张图中，回溯&amp;匹配失败后，其他路径。恩，就这样。 匹配匹配就通过正则表达式里面的规则匹配字符串的内容，在匹配的过程中通常不涉及分支或者量词等等。 JavaScript中如何使用正则表达式 RegExp对象 RegExp的exec方法 RegExp的test方法 String的match方法 String的replace方法 String的search方法 String的split方法 创建一个正则表达式 12345671.var regex = /pattern/flags;使用正则表达式字面量模式 var regex = /abc+c/2.var regex = new RegExp(pattern,[,flags])；使用RegExp构造函数 var regex = new ReExp(&quot;ab+c&quot;); var regex = new RegExp(/ab+c/,&quot;gi&quot;) var regex = new RegExp(&quot;ab+c&quot;,&quot;gi&quot;) 其中有很多细节，可以在《高程》p103查看 RegExp对象的exec方法 12var myRe = /d(b+)d/g;var myArray = myRe.exec(&quot;adbbbbddbbbd&quot;); 对象 属性或者索 描述 在例子中对应的值 myArray 匹配到字符串和所有被记住的子字符串 [“dbbbbd”,”dbbbd”] index 在输入的字符串中匹配到的以0开始的索引值 1 input 初始字符串 “adbbbbddbbbd” [0] 在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串 myRe lastIndex 下一个匹配的索引值，这个属性只有在使用g参数时，可以通过参数进行高级索引7 source 模式文本，在正则式创建时更新，不执行 “d（b+）d” ####R egExp的test方法 test()接受一个字符串参数。他只测试目标字符串与某个模式是否匹配，如果匹配返回true，否则返回false； String的match方法 详细《高程》p126match（）接受一个参数，要么是一个正则表达式，要么是一个RegExp对象与高程上面说法相反，不知道是什么原因？ String中search()方法 这个方法中唯一的参数和match（）中相同，返回字符串中第一个匹配的索引；如果没有找到匹配项，则返回-1.而且search（）方法始终从字符串的开头向后查找模式。 String的replace方法 replace（）接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么会替换第一个字符串，要想有、替换所有的子字符串，唯一的办法就是提供一个正则表达式，而且指定全局（g）标志，如下： 12345var text = &quot;cat,sat&quot;var result = text.replace(&quot;at&quot;,&quot;ond&quot;);alert(result) //&quot;cond,sat&quot;result = text.replace(/at/g,&quot;ond&quot;);alert(result);//&quot;cond,scond&quot;; 详细的《高程》p127 ####String的split方法 这个方法可以基于指定分隔符将一个字符串分割成多个子字符串，并且将结果放在一个数组中。分割符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式），split方法可以接受可选的第二个参数，用于指定数组大小。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型、原型链]]></title>
    <url>%2F2018%2F08%2F27%2F%E4%B8%80%E3%80%81%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[引用自王福朋老师的经典博文，加上自己的理解完成的一篇博文 一、一切都是对象？“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。 1.什么是对象（通俗） 对象就是属性的集合 2. 怎样创建对象构造函数就是构建新对象的：使用new来调用函数，或者说发生构造函数调用时： 创建（或者构造）一个全新的对象 这个新对象会被执行[[prototype]]连接 这个新对象会被绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。--91页 123456function Fn() &#123; this.name = '王福朋'; this.year = 1988;&#125;var fn1 = new Fn(); console.log(typeof fn1) //Object类型 上面例子很简单，它能够说明：对象可以通过函数来创建的，但是说–对象都是通过函数创建的–有些人可能反驳：不对！因为： 123456789101112131415var obj = &#123; a: 10, b: 20 &#125;;var arr = [5, &apos;x&apos;, true];console.log(typeof obj) //Objectconsole.log(typeof arr) //Object//（语法糖）相当与//var obj = new Object（） obj.a = 10; obj.b = 20; var arr = new Array(）; arr[0] = 5; arr[1] = &apos;x&apos;; arr[2] = true; //这样就是function Array（）和function Object（）创建的对象 //证明了对象都是由函数创建的 3.函数是通过什么创建的123456789101112131415161718 var sum = function (num1, num2) &#123; return num1 + num2; &#125; var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); console.log(sum) //function //函数是通过new Function（）构建的 //这样就是function Array（） //function Object（） //function sum（）， //其中Object和Array，sum都是函数，这些函数都是通过new Function（···）创建的，然后这些函数再去创造对应的对象，//function Function（），这个是实例化创建函数（函数的创建工厂）//现在将引用类型分为2种//一种是通过new Function创建的函数，另一种是通过function（构造函数）创建的对象 在 JavaScript中，函数是头等(first-class)对象，因为它们可以像任何其他对象一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。 —–简而言之，它们是Function 对象。 4.验证上面说法1234567891011121314151617181920212223242526272829303132333435 function show(x) &#123; //typeof输出类型的标识 console.log(typeof x); // undefined console.log(typeof 10); // number console.log(typeof &apos;abc&apos;); // string console.log(typeof true); // boolean //引用类型 console.log(typeof function () &#123;&#125;); //function console.log(typeof Array) //function console.log(typeof Object) //function console.log(typeof [1, &apos;a&apos;, true]); //object console.log(typeof &#123; a: 10, b: 20 &#125;); //object console.log(typeof null); //object console.log(typeof new Number(10)); //object &#125; show();``` #### 5.总结：* 对象就是属性的集合* 对象都是由函数创建的* 函数实际上是new Function（）的实例对象，因此函数就是Function对象，可以像任何其他对象一样具有属性和方法。但是上面那张图片解释很奇怪，想一下，##### 问题一 ：function Function（）这个函数由什么创建的 console.log(typeof Function) //functionfunction Function（）用来创建函数，但他自身也是一个函数，难道是他自己创建自己的吗？，很奇怪，对吧。##### 问题二：Function 为什么判断即是对象也是函数（需要使用instanceof机制解决） //判断一个变量是不是对象很简单,引用类型的类型判断用instanceof //这个和instanceof查询机制有关 var fn = function () {}; console.log(fn instanceof Function);//true //但是 console.log(Function instanceof Object); // true console.log(Function instanceof Function) //true 123456789101112131415161718所以我们暂且将Function这个函数排除在外，下面所讲的函数都是由function Function（）实例化的不包括function Function（）## 二、prototype原型和\__proto__隐式原型上面说过函数也是一种对象。他也是属性的结合，可以自定义属性#### 1.函数的prototype属性Javascript中默认给**函数**一个属性--prototype。每个函数都有一个属性叫做prototype，这个prototype属性值是一个**对象**（属性的集合）默认的（）有一个叫做**constructor的属性，指向这个函数本身**![此处输入链接的描述][3]`SuperType.prototype.constructor === SuperType`superType是一个函数，右侧就是他的原型。我们可以在prototype中自定义一些属性 function Fn() { } Fn.prototype.name = &apos;王福朋&apos;; Fn.prototype.getYear = function () { return 1988; }; console.log(Fn.prototype); 123456789这时Fn的原型就添加了这几个属性![此处输入图片的描述][4]但是这样做有什么用？按照一段代码显示就是 function Fn() { } Fn.prototype.name = &apos;王福朋&apos;; Fn.prototype.getYear = function () { return 1988; }; var fn = new Fn(); console.log(fn);//出现__proto__属性 console.log(fn.name); console.log(fn.getYear()); console.log(fn.prototype);//undefined 1234567这时Fn是一个函数，fn对象是Fn函数中new出来的，这样fn对象就可以调用Fn.prototype中的属性。#### 2.对象（函数对象）的\__proto__每个**对象（包括函数对象）**都有一个隐藏的属性“\__proto__”，这个属性**引用**的**创建这个对象的函数的prototype**。这个隐藏的属性成为**隐式原型**prototpe存在的意义就是给对象（函数对象）的\__proto__引用 var o1 = {a : 1, b : 2, c : 3, }; console.log(o1.proto === Object.prototype)`即，每个对象（包括函数对象）都有一个__proto__属性，指向创建该对象的函数的prototype。 那么上图中的“Object.prototype”也是一个对象，它的__proto__指向哪里？ 好问题！ 在说明“Object prototype”之前，先说一下函数的prototype。函数的prototype本质上就是和 var obj = {} 是一样的，都是一个对象，都是被Object创建，所以它的__proto__指向的就是Object.prototype。 但是Object.prototype确实一个特例——它的__proto__指向的是null，切记切记！ 根据上面都知道函数是根据Function创建出来的，那么我们猜测函数（Function对象）的__proto__应该指向Function.prototype 3.如何解释上面那个奇怪问题上图中，很明显的标出了：自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，唉，怎么还有一个……Function.proto指向Function.prototype？这不成了循环引用了？（proto指向创建自己的函数原型）对！是一个环形结构。 其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的proto指向了自身的Prototype。所以回答上面那个问题-Function是被自身创建的。 三、老朋友instanceof的查询机制对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。这个时候就需要用到instanceof。例如： 这是我们需要知道instanceof的判断规则Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。 通过上以规则，你可以解释很多比较怪异的现象，例如： 这些看似很怪异的现象，其实都是根据上面的查找方法；比如现在咋们就分析这张图片 prototype是原型，是对象的__proto__属性将创建自身函数的prototype连接（引用），层层连接形成一条最后指向Object.prototype.__proto__===null的链，称之为原型链。 instanceof这样设计，就是根据原型链，或者说是继承吧 这样现在就很好理解一切都是对象这个说法了，所谓的原型链就是上面”__proto__”这条链状结构了 Object 是一个 JS 基础类型，其他所有类型都从 Object 继承了基本的行为。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D云标签/3D旋转链接设计思路（简单实现）]]></title>
    <url>%2F2018%2F08%2F27%2F%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[设计思路需要用到数学知识 弧度跟角度的转换公式是：弧度=π/180 * 角度。 在空间中，以坐标原点为球心，半径为R的球面参数方程为：1234x = r * sinθ * cosΦ; y = r * sinθ * sinΦ; z = r * cosθ;说明：θ为点跟圆心的连线与z轴的夹角，Φ是点跟圆心连线在xy平面投影线与x轴的夹角（可以根据需要建立不同的坐标系，或者取不同的夹角，坐标的表达方式可以有很多，但原理是类似的） 3.旋转公式(这是绕着一个点)具体网站123x1 = cosθ * x - sinθ * y;y1 = cosθ * y + sinθ * x;说明：（x,y）是开始的坐标，θ是旋转的角度，（x1,y1）是结束的坐标。球绕某一条轴的旋转可以抽象成圆绕圆心旋转，根据旋转前的坐标和角度可以求出旋转后的坐标。 原理： 将标签看做一个点，通过设置不同的将他们平均分布到球面个各个坐标点上，旋转x轴或者y轴达到旋转球体的目的，z轴实际上不存在，和我们的屏幕垂直，通过近大远小达到视觉欺骗的效果， 开始实现： 设置每个坐标(通过设置len可以控制标签数量) 1234//在init（）函数中实现θ = arccos(((2 * i) - 1) / len - 1);Φ = θ * sqrt(len * π);//len是设置的个数，每次返回一组小球的两个角度 2.循环计算出每个小球的坐标并且将小球坐标存到自身对象中 12345678//init（）初始函数，在这个函数中调用move函数（下面是init函数主要内容）for (var i =0,len = tag.length;i&lt;len;i++) &#123; let a = Math.acos(((2 * i) - 1) / len - 1); let b = a * Math.sqrt(len * Math.PI); tag[i].x=R*Math.sin(a)*Math.cos(b); tag[i].y=R*Math.sin(a)*Math.sin(b); tag[i].z=R*Math.cos(a);&#125;; 3.然后根据每个元素对象上面的坐标将对应的元素摆放到对应的地方 123456789101112//函数名称：move（）根据对应位置将元素放置在DIV上面，然后调用animate（）函数进行动画for(var i = 0,len = tag.length;i&lt;len;i++)&#123; tag[i].style.left = tag[i].x+ 250+&apos;px&apos;; tag[i].style.top = tag[i].y+250+&apos;px&apos;; tag[i].style.transform = &quot;scale(&quot;+((tag[i].z+300)/400)+&quot;,&quot;+((tag[i].z+300)/400)+&quot;)&quot;; //设置翻转效果 if(tag[i].z&lt;0)&#123; tag[i].style.color = &quot;#888&quot;; &#125;else&#123; tag[i].style.transform = &quot;#000&quot; &#125; &#125; 4.编写小球的旋转函数，有两个一个是根据X轴，一个是根据Y轴进行旋转旋转使用的函数是（根据上面的计算方式）： 12345678910111213141516171819202122//angleX，angleY是我定义的全局变量，用来判断此时钻洞角度 function rotateX()&#123; var cos = Math.cos(angleX); var sin = Math.sin(angleX); for(var i = 0,len = tag.length;i&lt;len;i++)&#123; let y = tag[i].y * cos - tag[i].z * sin, z = tag[i].z * cos + tag[i].y * sin; tag[i].y = y; tag[i].z = z; &#125; &#125; function rotateY()&#123; var cos = Math.cos(angleY); var sin = Math.sin(angleY); for(var i = 0,len = tag.length;i&lt;len;i++)&#123; let x = cos*tag[i].x-sin*tag[i].z; let z = cos*tag[i].z+sin*tag[i].x; tag[i].x= x; tag[i].z=z; &#125;&#125; 5.制作动画函数动画实现自动旋转，或者改变旋转角度（angleY和angleX）时候调用的函数 123456789//调用rotateX（）和rotateY（）根据偏转角度更新tag[i]的坐标，然后调用move（）进行重新排列 function animate()&#123; clearInterval(timer); timer = setInterval(function()&#123; rotateX(); rotateY(); move(); //这个函数根据坐标改变元素位置 &#125;,30) &#125; 6.具体整个动画框架就构造完成，需要什么就直接更改就可以；下面贴出整个代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function(global, undefined) &#123; var R = 200; //这个球的半径 var tag = document.querySelectorAll(&quot;.tap&quot;); //所有的标签 var angleX = .005; //X偏转角度 var angleY = .005; //Y轴偏转角度 var timer = null; //动画定时器 //初始函数将标签进行平均分配 var init = function() &#123; for (var i = 0, len = tag.length; i &lt; len; i++) &#123; let a = Math.acos(((2 * i) - 1) / len - 1); let b = a * Math.sqrt(len * Math.PI); tag[i].x = R * Math.sin(a) * Math.cos(b); tag[i].y = R * Math.sin(a) * Math.sin(b); tag[i].z = R * Math.cos(a); &#125;; move(); //调用绘制函数 animate(); //动画函数 &#125; //按照tag对象中的将标签绘制到cloud中 function move() &#123; for (var i = 0, len = tag.length; i &lt; len; i++) &#123; tag[i].style.left = tag[i].x + 250 + &apos;px&apos;; tag[i].style.top = tag[i].y + 250 + &apos;px&apos;; tag[i].style.transform = &quot;scale(&quot; + ((tag[i].z + 300) / 400) + &quot;,&quot; + ((tag[i].z + 300) / 400) + &quot;)&quot;; //设置翻转效果 if (tag[i].z &lt; 0) &#123; tag[i].style.color = &quot;#888&quot;; &#125; else &#123; tag[i].style.transform = &quot;#000&quot; &#125; &#125; &#125; function rotateX() &#123; var cos = Math.cos(angleX); var sin = Math.sin(angleX); for (var i = 0, len = tag.length; i &lt; len; i++) &#123; let y = tag[i].y * cos - tag[i].z * sin, z = tag[i].z * cos + tag[i].y * sin; tag[i].y = y; tag[i].z = z; &#125; &#125; function rotateY() &#123; var cos = Math.cos(angleY); var sin = Math.sin(angleY); for (var i = 0, len = tag.length; i &lt; len; i++) &#123; let x = cos * tag[i].x - sin * tag[i].z; let z = cos * tag[i].z + sin * tag[i].x; tag[i].x = x; tag[i].z = z; &#125; &#125; //制作动画函数 function animate() &#123; clearInterval(timer); timer = setInterval(function() &#123; rotateX(); rotateY(); move(); &#125;, 30) &#125; window.init = init;&#125;)(window)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器同源策略及规避Ajax中jsonp跨域解决方案]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E8%A7%84%E9%81%BFAjax%E4%B8%ADjsonp%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[了解下浏览器的同源策略，并且理解下jsonp的跨域解决方案 浏览器同源策略及规避Ajax中jsonp跨域解决方案同源策略-知乎浏览器的同源策略-MDN 什么是：“同源策略”。 判断两个url是不是同源 了解现代浏览器的部分同源策略 jsonp实现原理 同源策略（SOP）一、同源策略是什么？1.1出现1995年，同源策略由Netscape公司引入到浏览器也是由Netscape提出的一个著名的安全策略。直至目前为止，所有的浏览器都在使用这个策略。 1.2含义所谓的“同源”指的是三个相同 协议相同 域名相同 端口相同 我们将三个相同的视为同一个域，一个域的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其他域的资源。这种安全限制称之为同源策略。 详细例子： 小问题：是否允许进行通信（依赖浏览器实现） http://www.a.com:80/page1.htmlhttp://www.a.com/page2.html 二、现代浏览器的同源策略-不受限制（部分规则）1.1、现代浏览器同源策略出现背景安全性和方便性是成反比的，十位数的密码提高了安全性，但是不方便记忆。同样，同源策略提升了Web前端的安全性，但牺牲了Web拓展上的灵活性。设想若把html、js、css、flash，image等文件全部布置在一台服务器上，小网站这样凑活还行，大中网站如果这样做服务器根本受不了的，可用性都不能保证的话，安全性还算个吊？所以，现代浏览器在安全性和可用性之间选择了一个平衡点。在遵循同源策略的基础上，选择性地为同源策略“开放了后门”。 1.2、开放的后门所以就有不受同源策略限制的： 123456多媒体元素标签&lt;img src=&quot;&quot;&gt;脚本标签&lt;script src=&quot;&quot;&gt;样式标签&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;&lt;frame&gt;, &lt;iframe&gt;&lt;a&gt;还有其他的··· 1.3、不是绝对的（考虑这是什么的端的限制，Node为什么可以获得文件）今天所讲的都有一个前提是浏览器针对同源策略的一种实现 但是这不是绝对的；例如img script style等标签，都允许垮域引用资源，严格说这都是不符合同源要求的（怎么理解）。然而，你也只能是引用这些资源而已，并不能读取这些资源的内容，不信你可以试试：在你自己的域内读取百度logo图片的内容，以读取到二进制数据为准。（暴脾气，试试就试试，who怕who）你很快发现这是不可能的，你顶多只能判断这张图片是否存在（使用的img标签的onerror属性 ）。因此浏览器降低了那么一点点安全性，却大大提升网站布置的灵活性。 三、现代浏览器的同源策略-限制（部分规则）1.1、限制内容随着互联网的发展，“同源策略”越来越严格（原因都知道，互联网安全越来越重要），直到目前，如果非同源，总共有三种行为收到限制。 Cookie、LocalStorage和IndexDB无法读取 DOM无法获取 AJAX请求不能发送（XmlHttpRequest对象向不同源的服务器地址发送HTTP请求） 1.2、为什么要限制为了保证用户信息安全，防止恶意网站窃取数据。 1.2.1、Cookie的无法读取设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源策略的限制（我的理解是：Cookie是一个可以识别你身份的东西，不一定保存账号名和密码，或许仅仅是一个登录ID，让服务器知道你的身份避免重新登录，这里面也很多知识，仅仅是我现在的了解） 1.2.2、DOM无法获取再举个例子，现在我扮演坏人 我通过一个iframe 加载某宝的登录页面 等傻傻的用户登录我的网站的时候 我就把这个页面弹出 用户一看 阿里唉大公司 肯定安全 就屁颠屁颠的输入了密码 注意 如果没有同源策略 我这个恶意网站就能通过dom操作获取到用户输入的值 从而控制该账户 1.2.3、AJAX请求为什么不能跨域请求AJAX同源策略主要用来防止CSRF攻击。如果没有AJAX同源策略，相当危险，我们发起的每一次HTTP请求都会带上请求地址对应的cookie，那么可以做如下攻击： 用户登录了自己的银行页面 http://mybank.com，http://mybank.com向用户的cookie中添加用户标识。 用户浏览了恶意页面 http://evil.com。执行了页面中的恶意AJAX请求代码。 http://evil.com向http://mybank.com发起AJAX HTTP请求，请求会默认把http://mybank.com对应cookie也同时发送过去。 银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。而且由于Ajax在后台执行，用户无法感知这一过程 由此可见，”同源策略”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。感谢有同源策略，用户才有勇气使用互联网。 四、IE的例外IE同源策略-MDN 五、总结1.1、同源策略的含义？1.2、同源策略的设计目的，同源策略为了解决什么问题，我们为什么要了解同源策略？ 设计目的：同源策略就是希望来自同一个源的页面和脚本可以基本没有什么限制的进行交互；对于不同源的进行隔离 解决什么问题:为了安全起见和资源的有效管理，最直接话就是：浏览器的安全基石 我们为什么要了解：解决一个痛点，不同域名下的资源读写。 1.3、本篇博文的同源策略的前提？ 浏览器只是针对同源策略的一中实现 1.4、同源策略的一些规则？《Web前端黑客技术揭秘》非常系统的讲解了前端安全知识，这些都是围绕同源策略展开的。所以对于浏览器的同源策略这个问题可以很小，同样也可以很大。 浏览器同源策略规则下如何规避DOM规则一、document.domain1.1、主要场景禁止对不同源页面DOM进行操作。这里主要场景就是iframe跨域的情况，不同域名的iframe是限制互相访问的。 1.2、使用情况不同窗口（window）或内敛框架元素之间互相访问文档内容，包括cookie 1.3、实现前提 协议、端口相同 当前域名的父域相同 其中一个窗口或iframe能得到另一个窗口或iframe引用 上面所述父域不能为顶级域名（或者说是一级域名）实例https://zhuanlan.zhihu.com/p/28562290JS提升二级域名（document.domain+iframe子域名代理） 1.4、举例比如a页面地址为 http://a.yourhost.com b页面为 http://b.yourhost.com。 这样就可以通过分别给两个页面设置 document.domain = yourhost.com 来实现跨域。 之后，就可以通过 parent 或者 window[‘iframename’]等方式去拿到iframe的window对象了。实现不同源页面DOM操作 浏览器同源策略规则下如何规避AJAX的规则二、JSONP1.1、主要场景禁止使用XHR对象向不同源服务器地址发起HTTP请求 1.2、出现原因因为&lt;script src=&quot;&quot;&gt;&lt;/script&gt;标签不受同源策略的限制 1.3、实现具体思路就是：利用script元素的src属性，页面可以向任何域的服务器端请求数据，服务器接收到请求以后，将json数据（或者其他）传入一个指定名字的回调函数里，再传回给客户端，这样客户端就可以处理返回的数据（实现了跨域），这种使用模式就是所谓的JSONP 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; function handleResponse(response)&#123; console.log(response); &#125; //找一个点击的按钮 var oBtn = document.getElementById(&apos;btn&apos;); oBtn.onclick = function() &#123; let script = document.createElement(&quot;script&quot;); script.src=&quot;请求地址?callback=handleResponse&quot;; document.body.insertBefore(script, document.body.firstChild); &#125; &#125;;&lt;/script&gt; 1.4、callback详细过程详细理解可以看jsonp和json - 博客园 假设服务器端有数据“foobar”需要传给客户端。在客户端定义如下函数用来对数据进行打印、警告灯操作：1234567function print(e)&#123; console.log(e)&#125;function warn(e)&#123; alert(e);&#125; 假如说服务器端用来获取数据的url是 http://server.com/jsonp.php 然后我们使用标签发起如下请求 http://server.com/jsonp.php?callback=print 当这个php页面检测到callback参数的值时，会把要发送给客户端的数据包裹在print的函数调用里，变成这种样子返回给客户端（由后端处理，下面仅仅是一种处理方式）（后端的处理就是拼接字符串，形成一个javascript代码段） 返回：print(&quot;foobar&quot;); 这样对这个请求的结果其实就是一段javascript代码 由此我们可以知道，jsonp实际上是和后端进行配合，后端需要保证输出的response text必须符合js语法，如果在请求过程中出现语法报错或者仅仅返回json数据不是javascript代码段，则可以判定这个接口不支持jsonp 1.5、例子详细探究 返回到script中的内容是什么？进行分析？//参考这个cache.video.iqiyi.com/jp/avlist/202861101/1/?callback=jsonp9和https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse 例子的回调函数放置的位置有没有影响？ 分析一个不支持jsonp的接口，观察这个出错原因？ 了解callback这个名字，只是前后端约定的一个名字 1.6、json和jsonp区别jsonp就是json格式的数据，但是和json有什么不同？ content-type不同json是application/json，jsonp是text/javascript。意思是jsonp对浏览器而言内容是javascript。就是因为加载javascript允许跨域，使用json的content-type就不能跨域访问。 ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 1.7、ajax中json具体过程 $.ajax方法会动态创建一个script标签，将url的值赋给src属性，将data的数据拼接在src地址后面 当将dataType设置为jsonp后，把这个方法的名字拼接在url的后面传递给服务器 在服务器的内部，首先会获取到前端传递过来的方法名，然后在方法名后面拼接需要传递过去的数据，在最后返回的是一个已经拼接好的参数的方法调用。 前端接受到后台返回的字符串 会当做js进行解析 将动态创建的标签删除。 1.8、优缺点优点 可以跨越同源策略。 兼容性很好 缺点 仅仅支持get请求，不支持post请求 仅仅支持跨域http请求这种情况，不能解决两个页面之间的如何进行JavaScript调用的问题 Jsonp在调用失败的时候不会返回各种http状态码 缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个 jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大一总结]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前天刚将计算机三级（网络技术）考完，感觉很稳，前前后后总共花费大概10天的时间，就将整本计算机三级教材过了3遍并且做了10套题，自己能够将这些看完，我还是感觉平时的积累真的很重要，说不定什么时候就能用到，也不论用的到用不到，每一种知识都是对思维的一种拓展，大学学习知识，更多的是拓宽思维面，前一段时间去听计科那边的‘面向对象的分析与设计’，老师当时提到：为什么这么多学生抱怨学习了c++，但是学院却不教我们使用更为广泛的java，可能学了很久的学长都知道老师的意思，但是我当时并不知道老师想表达什么。直到最近我们学院开始学习java，我才真正知道，两者之间没有什么区别，老师想说的更多的是一种思维的形成，或者通过C++来打开学生自由思考、自由学习的大门，这两件事情对我感触都比较大，更加坚定大学的每一门课，都有选修的必要，不论别人对这门课的态度，自己一定全心全意接纳、吸收这门课的精华。其次，更多是在大学培养辩证性思维，更多的去总结、分析问题，而不要一味带有价值思考来决定自己对此门课程的态度。我知道这些会花费我很多时间，但是这些时值得的。考完试的第四天晚上，我坐在寝室来开始总结自己这大一的一些情况，前几天在勤奋峰心愿墙上面写上自己的心愿，当时认真思考，决定要将心中所想的这次全部形成一文字记录，然后当我大二，大三，大四每年都会在再写自己的心愿，将四年进行对比，可能更加了解自己，同时我需要为自己留下回忆，大学四年时间太短，权且将自己心中所想留在一张篇博文里面吧！ 先说说自己大一的情况吧谈兴趣：我发现自己喜欢互联网，喜欢经济管理，喜欢电子商务，喜欢慢跑、网球 谈学业：专业绩点排名6，平均成绩排名3，综合素质排名4 谈工作室：从开学知道这个就一直想要加入，最后最后加入勤奋峰团队学习前端开发。 谈理想：理想一直在路上，从未放弃，也从未停止。 谈性格：变化还是比较大的，有好有坏，但都无关紧要，自己一直努力，然后等吧··· 谈缺点： 确实给自己太实的，效率有时很低，大二不要这样，这学期一定改正 不能微笑对待别人，自己常常会感到表情僵硬，不自然。这是病，得治！让自己快乐，让别人也要快乐嘛 性格有点直，平时会忍忍，原则性问题绝对不退让。不改 以前有点“高冷”，现在将自己放低，谦虚，主动向别人问好，做到不卑不亢，虽然也有可能被被人看成SB，但是就那样吧！SB欢乐多 不自信，就算自己认为对的事情，但是也会随大流，这是我目前认识到最大的问题，我觉得这些我能够做到张弛有度的话，前面的那些问题必将不攻自破。这一学期选修了‘电子商务创新与创业’我要在这门课上开始第一次尝试。 对于有些人际关系确实很头痛，脑壳大，可能就是自己现在性格还没有形成吧，我要有自己的性格特点（个性），让别人能够立刻、马上用几个词语可以以形容出我自己，我会去问的。 优点：嘿嘿！心里有就行可以了，说出来可能就偏了 感谢大一这一年没少让别人帮助，父母的苦口婆心，老姐的鼓励，理解，瑜姐对我提的建议，帮助我制定一些计划，这些都让我受益匪浅，虽然口头上不会表现出来，但是我心里感谢。然后就是加入部门，遇见邓超（超哥），高老师，帮助那个从一开始那个自卑，胆怯的孩子慢慢适应大学的生活，找到自己的节奏的我，“无所畏，有所为”这是高老师告诉我的，要想有所作为，就不要怕每次表现，但是现在还是考虑有点多。下面就是我们c语言老师，曹慧英，讲课幽默生动，帮助我们这些不知所以的新生打开计算机世界的大门，开始正式进入计算机语言世界，是我的启蒙老师吧，我的兴趣可能和曹老师有直接的关系，下学期，我遇见我们学院主任-杜茂康教授（康哥，杜老，杜康），他代我们面向对象的程序设计这门课，实力强劲，对于问题研究的比较深，上课喜欢拿自己开玩笑，和老师请教交流中，慢慢发现老师的优秀品质，谦虚-拿自己开玩笑，给我讲问题从来不是贯彻性的讲述，而是一种平等的对问题的思考和解决。爱学生-我们这个专业，他是我们专业的主任，算是专业的元老级人物，对这个专业投出了大量的心血。这个专业可以说是他的孩子一样，是康哥的骄傲，康哥很关心我们，不论是平时上课对待问题还是给我们寻找优秀学长来分享，还是很小心的提醒我们上课别走神，等等，无一不体现出一种说不出的情感。对于我的三个室友，都挺好的，容忍了我很多，同样我也忍了他们很多，就是这样，我们慢慢学会了互相尊重，尽量在这个狭小的寝室为他人留下一点属于自己的空间，感谢这几位室友。感谢学长、学姐，不论是辩论队的那个学长，还是工作室里面带我的杨怡学姐，还是勤奋峰里面帮助我们的唐燕学姐等等，让我在深夜里悄悄对你们说一声谢谢。 现在谈谈自己大二的目标吧关注重点：工作室学习，创新创业大赛，性格修炼 学业方面：重点学科：‘java’，‘数据库原理’，‘管理运筹学’，‘概率论与数理统计’，‘面向对象的分析与设计’，‘电子商务概论B’其次就是英语四级没有过去，心里很不舒服，这一学期，积累然后下一学期将四级考过。英语为重中之重，我怎么可能放弃吗，笑话 工作室学习：大二一年，最终目标：做个App、开源项目吧！具体目标每周去规划吧！生活方面：衣服不堆积，床单要干净整洁，衣柜里面的衣服要摆放整齐，养成良好的生活习惯。 社会实践：上一年也体验了下来，血液中心的志愿服务让给感觉意义很大，但是相比有津贴的重庆科技志愿馆，我应该更适合，毕竟不是有钱人，那点津贴对于生活的改善还是有帮助的。其次就是大学生兼职这个问题，上次体验了一下，很简单，但是这学期会减少去做兼职，抓住时间，一直感觉时间不够用。 学习效率重点提出这个问题，效率很重要很重要，为自己创造一切最有利的条件和环境。 下面谈谈自己在大学出来的目标 一定按照学校校训严格要求自己“修德，博学，求实，创新” 大学四年，培养一个自己的性格和良好的生活习惯 大学四年，改变自己的思维方式，辩证性思维-创新性思维 大学四年，培养一个良好的口头表达能力 大学四年，能够得到阿里巴巴的offer，毕竟很喜欢互联网电子商务 上面这些都比较散，但是都是自己真心想做到的事情，我相信吸引力法则，让现实向我计划的方向走去。然后加油吧！把握好每一天，实现自己的目标，这就是我最开心的事情。再然后，晚安！好梦]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动登录的实现方式]]></title>
    <url>%2F2018%2F08%2F26%2F%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[最近在做crm系统的时候使用antd-pro有一个自动登录的功能，当时不知道怎么实现，以为antdh-pro做了封装，后面被学长问道然后再去看代码，发现antd-pro压根没有实现自动登录，由于时间比较紧，自己将这个需求放置二期进行开发，这几天学习了一些自动登录的实现方式，在这篇博文进行总结下这种实现方式 最佳实践 在数据库添加一张表用于保存用户登录信息，暂且命名为auto_login,里面含有id、user_id、auto_login_hash、user_name、create_time` 当用户点击自动登录的时候，后端返回的Set-Cookie不仅仅只有sessionid（会话cookie），同时还包括auto_login_hash、user_name，expires通常设置为2周或者由开发者决定 当用户关闭浏览器再次访问我们的网站的时候，前端检测如果有auto_login_hash和user_name但是没有sessionid，这时候我们就发起一个Ajax，通过auto_login_hash和user_name请求登录 后端根据传过来的auto_login_hash和user_name检测auto_login表中是否含有对应的记录，如果有，则代表这个用户是可以登录，同时生成新的auto_login_hash值，create_time不变动，将auto_login_hash和user_name和sessionid返回给前端，完成一次自动登录 用户点击注销，删除sessionid的同时也将对应的auto_login表中的对应信息删除 问题 为什么要再次生成auto_login_hash? 考虑到安全，如果前端的auto_login_hash被截获，攻击者利用这个auto_login_hash模拟用户登录，成功之后会有新的auto_login_hash生成，这时候如果真正的用户访问我们的网站就会判断，我们对比auto_login_hash和数据库中的，发现不同，这时候就可以判断用户账号有问题，清除用户的auto_login_hash，让用户重新使用用户密码进行登录，这样可以提高系统的安全性]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux：centOS 程序安装]]></title>
    <url>%2F2018%2F08%2F01%2FLinux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装过程window软件安装过程 在用户指定的安装目录下建立安装程序目录 拷贝相关dll动态库到安装目录 拷贝exe可执行文件到安装目录 拷贝配置文件到安装目录，比如window下的ini配置文件 把启动配置或者程序依赖的配置放入注册表中 如果是服务程序，注册并启动该服务 Linux安装软件大概的过程 建立安装目录 拷贝类库 拷贝可执行文件 根据需要选择性配置和启动服务 注意 linux上/usr目录相当与window上ProgramFile目录 Linux上动态库后缀是.so，window上面的是.dll 编译安装 什么是编译 高级语言编写的程序通过编译器转化为机器语言，有些编译器直接将高级语言程序转化为汇编语言，然后使用一个汇编程序（assembler）将其转化为机器语言。经常与编译一起使用的步骤就是链接，链接的好处就是多个程序共享这个。提供这种通用任务支持的功能便是库，库中包含多个例程，每一个实现都是许多程序能够共享的的通用任务，一般下/lib和/usr/lib目录中，链接器（linker）程序可以实现编译器的输出与编译程序所需要库之间的链接。该操作的最后结果就是生成一个可供使用的可执行文件。 发行版本自行安装的源代码一般安装与/usr/src目录下 面向多用户使用的源代码一般安装在/usr/local/src目录中 默认编译器，gcc编译的四个阶段（预处理-编译-汇编-链接） 下载解压源代码 软件一般使用c或者c++编写，一般都可以在软件官网上找的，使用wget进行下载 下载之后一般格式为.tar.gz、.tar.baz2 一般解压之后，文件中都会有README文件，这个文件软件说明所能完成的功能、授权许可、安装需求、安装注意事项、安装方式等等 分析安装环境 软件解压之后，进入解压之后目录，一般都会存在configure这个文件，这个文件是一个shell脚本，他的任务就是分析生成环境，linux下软件的安装受到操作系统安装环境的影响，比如某些软件在安装或者运行过程中需要调用操作系统本身的库文件，或者需要运行系统的某个工具等等，但是系统中不存在这个库文件或者这个工具没有安装，那么安装或者运行软件就会失败。为了避免这个问题的出现，在安装软件的时候就需要分析操作系统环境，检测当前系统是否拥有安装软件所需的所有文件和工具，如果系统缺少某个文件，就给出提示，直到满足软件的所有需求为止。这个就是configure文件的功能，configure文件一般是个可执行文件，可以在当前目录下直接输入“./configure”进行软件安装的环境测试，如果提示缺少某些安装包，就需要进行安装，直到测试通过。通常的，源码安装都需要GCC或者CC编译器，这些编译器一般在安装系统时定制安装包中的开发工具选项下，其实这也是我们在第二章安装linux系统中要求选择开发工具包的原因所在。 一般当configure运行结束，会在源目录创建几个新的文件，其中最重要的就是Makefile。Makefile是指导make命令如何生成可执行程序的配置文件，如果没有这个命令，下一步的make命令边无法执行。 此外，在执行configure分析软件需求时，还可以在“./configure”后面加上软件的安装路径以及安装所需的模块等等一些选项，来定制用户需要的软件功能。例如安装nginx时的选项： –prefix=PATH ： 指定nginx的安装目录。默认 /usr/local/nginx –conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为prefix/conf/nginx.conf –user=name： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。–group=name类似 –with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。使用-* -with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本4.4 - 8.30）并解压，剩下的就交给Nginx的./configure和make来完成。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。 –with-zlib=PATH ： 指定 zlib（版本1.1.3 - 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。 –with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装 –with-http_stub_status_module ： 用来监控 Nginx 的当前状态 –with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址 –add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译） 编译安装 这里主要分为两个步骤，首先是编译，使用make命令，根据Makefile自动完成所有源代码文件的编译工作，这个歌过程称之为构建（building），并且可以做到增量编译。打包好的源代码一般包含一个特殊的make目标程序，它便是install，该目标程序将会在系统目录下安装最后生成的可执行程序，通常会安装在目录/usr/local/bin下（未指定的话）。 make clean： 清除编译过程中产生的临时文件和配置过程中产生的文件。 Makefile教程： http://www.ruanyifeng.com/blog/2015/02/make.html 卸载编译安装的软件（最佳实践） 一般不推荐使用源码进行编译安装，如果软件有rpm包尽量避免使用源码安装 反安装 如果安装的时候指定安装目录，则删除指定目录即可（最优秀做法） 如果安装在/usr/*，则可以去执行make install的文件夹中执行make uninstall、make distclean、make veryclean等等命令 但不是每个源码都提供卸载命令，如果没有卸载命令的话，可以使用如下命令 借助checkinstall进行打包生成rpm包，进行安装 安装checkinstall 安装地址： http://asic-linux.com.mx/~izto/checkinstall/download.php 出错问题： http://www.361way.com/rpmbuild-checkinstall/3251.html 将未编译的源码进行打包生成rpm包，然后使用rpm进行管理。 执行./configure 执行make命令 执行checkinstall，根据提示创建一个rpm包 输入ms-sys命令测试是否可用 后面使用根据rpm规范进行使用 rpm命令安装软件:安装、删除软件包文件的任务的低级工具剩下的这两种方法其实完全没有讲的必要，只要理解rpm和yum是什么就ojbk了，剩下的许多操作，如果you 会English，you can use man yum 和 man rpm查看两条命令的具体用法，再不济，我下面会链接两篇优异的博文，里面有两条命令的具体使用方法。 RPM软件包分为二进制包（Binary）、源代码包（Source）和Delta包三种。二进制包可以直接安装在计算机中，而源代码包将会由RPM自动编译、安装。源代码包经常以.src、.rpm作为后缀名。 其实当有了源码的话可以生成各种类型的包，rpm包只是其中一种，比如上面我们使用checkinstall命令生成rpm包。 yum安装软件：元数据搜索以及提供依赖性解决的高级工具 yum的宗旨是自动化地升级，安装/移除rpm包，收集rpm包的相关信息，检查依赖性并自动提示用户解决。yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header， header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些 header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。 参考文档 四种linux安装方法、rpm和yum讲的比较好 《Linux命令行大全》 Linux软件安装方法]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux权限管理，实例：创建共享目录]]></title>
    <url>%2F2018%2F07%2F29%2Flinux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[重点说明 man &lt;命令&gt;：获取说明文档 apropos &lt;描述&gt;： 获取描述相关命令 用户基本操作 添加用户 adduser test //添加一个test用户 删除用户 userdel -r test //删除test用户 修改用户密码或者添加用户密码 passwd test // 为test用户设置密码 管理用户组 usermod -G root //将用户test分配到root组中。 组基本操作 添加组 groupadd test // 添加test组 修改组 groupmod -n test2 test // 将组test更名为test2 删除组 groupdel test2 //删除test2组 查看组 groups test //查询用户所在的组 查看用户 查看当前登录用户 who 查看单个用户信息 id test // 查test用户信息 查看用户登录信息 last // 查看用户登录信息 lastb // 查看用户失败登录信息 查看所有用户 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F&quot;:&quot; &#39;{ print $1&quot;|&quot;$3&quot;|&quot;$4 }&#39;|more cat /etc/passwd |awk -F \: &#39;{print $1}&#39; 其他命令 id： 显示用户身份标识 chmod： 更改文件的模式 chown： 更改文件所有者和所属群组 umask： 设置文件默认权限* su： 以另一个用户的身份运行shell sudo： 以另一个用户的身份来执行命令 需要更改/etc/sudoers 文件，为这个用户添加命令权限 chgrp： 更改文件所属群组 passwd： 更改用户密码 实例：创建共享目录 创建两个账户，并且为两个账户授予sudo权限（/etc/sudoers） 创建一个群组，并且将两个账户添加到创建的群组中 创建一个文件夹，作为共享目录，并分配其群组 为这个共享目录设置默认掩码（umask）、并设置目录sticky位权限（文件特殊权限，下面说明） 文件的其他几种权限 配置文件 /etc/passwd : 用户账户 /etc/group： 用户组定义 /etc/shadow： 用户密码信息 /etc/sudoers：可以使用sudo的哪条命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构排序算法]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[最近《数据结构（c语言）》课程结束，所以就想着整理一下《数据结构（c语言）》中的重点内容，因为我学习的是使用c语言进行实现，为了深入其中理解其中的过程，我计划使用ECMAScript实现其中的排序算法。 整体结构 插入排序1、直接插入排序123456789101112131415161718function insertSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr 不是数组&apos;); // 按照c语言方式，数组前推入一位作为监视哨 arr.unshift(undefined); console.time(&apos;插入排序耗时&apos;);for(let i = 2,length = arr.length; i &lt; length; i++) &#123; arr[0] = arr[i]; // 设置监视哨 if(arr[i-1] &gt; arr[i]) &#123; let j = i - 1; for(; arr[j]&gt;arr[0]; j--) &#123; arr[j+1] = arr[j]; // 记录后移 &#125; arr[j+1] = arr[0]; // 插入 &#125; &#125; console.timeEnd(&apos;插入排序耗时&apos;) return arr.slice(1);&#125; 2、折半插入（对直接插入的改进算法） 改进的主要内容在寻找插入位置的时候，使用折半算法，减少比较次数，然后常规移项，将节点插入 123456789101112131415161718192021222324function insertSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr 不是数组&apos;); // 按照c语言方式 arr.unshift(undefined); console.time(&apos;折半插入排序耗时&apos;); for(let i = 2,length = arr.length; i &lt; length; i++) &#123; let low = 1; let hight = i - 1; arr[0] = arr[i]; // 监视哨 // 和查找的折半算法不同，这一块找的是插入位置 while(low &lt;= hight) &#123; let m = parseInt((hight + low) / 2); if (arr[m]&lt;=arr[0]) low = m + 1; else hight = m - 1; &#125; for(let j = i-1; j &gt;= hight + 1; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[hight + 1] = arr[0]; &#125; console.timeEnd(&apos;折半插入排序耗时&apos;) return arr.slice(1);&#125; 3、希尔排序 出现原因 对于直接插入排序，其时间复杂度为O(n*n);但是，若待排序序列为“正序”时，其时间复杂度提升为O（n）。由此可以设想，当待排序列基本有序时，直接插入排序算法效率会大大提高。希尔排序正是从这两点分析出发，对直接排序算法改进得到的一种排序算法。 重要影响 1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 基本思想 先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，在对全体记录进行一次直接插入排序。 产生问题 就是这个增量该怎么选择？最简单的方法是第一轮排序的间隔为N/2，第二趟排序的间隔为N/4，依次类推。但是，实践证明，这种方法有时会使运行时间降到O(N2)，并不比插入排序的效率更高。保持间隔序列中的数字互质很重要，也就是说，除了1之外它们没有公约数。简单地取间隔为N/2，N/4，N/8…1时，没有遵循这一约束，所以使希尔排序的效率降低。 – &gt; 引用《算法（第四版）》 图示例（《数据结构（c语言）》） 123456789101112131415161718192021222324252627282930313233343536/** * * @param &#123;排序数组&#125; arr * @param &#123;间隔序列&#125; dk */function shellInsert(arr, dk) &#123; if(!Object.prototype.toString.call(arr).slice(8, -1) === &apos;Array&apos;) throw new TypeError(&apos;arr not Array&apos;); arr.unshift(undefined); // 用作暂存位 let length = arr.length; for(let i = dk + 1; i &lt; length; i++) &#123; if(arr[i] &lt;= arr[i - dk]) &#123; arr[0] = arr [i]; // 暂存位，注意和监视哨的区别 let j = i - dk; for(; j &gt; 0 &amp;&amp; arr[j] &gt;= arr[0]; j-=dk) &#123; arr[j + dk] = arr[j]; &#125; arr[j + dk] = arr[0]; &#125; &#125; return arr.slice(1);&#125;// 确定一个希尔排序间隔function insertSort(arr) &#123; let len = arr.length; let gap = 1; while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; console.time(&apos;希尔排序&apos;) for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; arr = shellInsert(arr, gap); &#125; console.timeEnd(&apos;希尔排序&apos;) return arr;&#125; 4、其他插入排序 2-路插入排序（p262 算法10.2） 表插入排序 （p268） 选择排序1、简单选择排序 123456789101112131415function selectSort(arr) &#123; console.time(&apos;选择排序&apos;); for(let i = 0,len = arr.length; i&lt;len; i++) &#123; let minKey = i; // 最小值 let minValue; for(let j = i+1; j &lt; len; j++) &#123; if(arr[j] &lt; arr[minKey]) minKey = j; &#125; minValue = arr[minKey]; arr[minKey] = arr[i]; arr[i] = minValue; &#125; console.timeEnd(&apos;选择排序&apos;) return arr;&#125; 2、堆排序 出现原因 在n个关键字中选择最小值，至少进行n-1次比较，然而，继续在剩余的n-1关键字中选择最小值就并非一定要进行n-2次比较,若是利用前面n-1次比较所得的信息，则可以减少以后选择排序所用的比较次数。则我们可以想到，必须有一个结构记录每次排序后的结果，所以这个结构我们称之为堆 堆的定义 基本思想 若在输出堆顶元素后，使得剩余的n-1个元素重新建成一个堆，则得到n个元素的次小值。如此反复执行。便能得到一个有序序列，这个过程称之为堆排序。 产生问题 ① 如何由一个无序序列构建成一个堆？② 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？我觉得我说不清这两个过程。p280参考，手动[滑稽] 图片参考 说明 测试了一下，我写的这个性能比较差， 感觉可能是因为使用递归的原因，后面在测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344function headAdjust(headData, headIndex) &#123; // headIndex以下变为堆 let headLeftIndex = 2 * headIndex; let headRightIndex = headLeftIndex + 1; let length = headData.length; let min = headIndex; // 最小节点 if(headLeftIndex &lt; length &amp;&amp; headData[headLeftIndex] &lt; headData[min]) min = headLeftIndex; if(headRightIndex &lt; length &amp;&amp; headData[headRightIndex] &lt; headData[min]) min = headRightIndex; // 进行替换 switch(min) &#123; case headLeftIndex: &#123; let temp = headData[headLeftIndex]; headData[headLeftIndex] = headData[headIndex]; headData[headIndex] = temp; headAdjust(headData, headLeftIndex); &#125;; break; case headRightIndex : &#123; let temp = headData[headRightIndex]; headData[headRightIndex] = headData[headIndex]; headData[headIndex] = temp; headAdjust(headData, headRightIndex); &#125;; break; default : break; &#125;&#125;function headSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr not Array&apos;); let headData = [undefined, ...arr]; // 使用顺序表存储 console.time(&apos;堆排序&apos;); // ①无序序列创建一个堆 for(let i = parseInt((headData.length-1) / 2); i &gt; 0; i--) &#123; headAdjust(headData, i); &#125; console.log(&apos;构造之后&apos;, headData); // ②输出堆顶元素调整剩余元素形成一个堆 for(let i = 1; headData.length !== 1; i++) &#123; arr[i-1] = headData[1]; // 取出当前 headData[1] = headData[headData.length-1]; // 将末尾的赋值给第一个 headData.length--; headAdjust(headData, 1); &#125; console.timeEnd(&apos;堆排序&apos;); return arr;&#125; 3、其他选择排序 树形选择排序 p277 交换排序1、 起泡排序（冒泡排序） 基本思想 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 图片参考 1234567891011121314function bubbleSort(arr) &#123; console.time(&apos;冒泡排序&apos;) for(let i = 0, len = arr.length; i &lt; len; i++) &#123; for(let j = len -1; j&gt;i; j--) &#123; if(arr[j - 1] &gt; arr[j]) &#123; let temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125; console.timeEnd(&apos;冒泡排序&apos;) return arr;&#125; 针对冒泡排序还有优化的方法（摘抄）具体戳十种排序算法 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 2、快速排序 基本思想 通过一趟排序将待排记录分为独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则分别对这两部分记录继续进行排序，以达到整个序列有序。 图示实例 p272 123456789101112131415161718192021222324252627function quickSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr not Array&apos;); console.time(&apos;快速排序&apos;); function sort(list, low, hight) &#123; if(low &lt; hight) &#123; let pivotloc = partition(list, low, hight); sort(list, low, pivotloc - 1); sort(list, pivotloc + 1, hight); &#125; return list; &#125; const data = sort(arr, 0, arr.length-1); console.timeEnd(&apos;快速排序&apos;); return data;&#125;// 返回排序后的位置function partition(list, low, hight) &#123; let value = list[low]; while(low &lt; hight) &#123; while(low &lt; hight &amp;&amp; list[hight] &gt;= value) hight--; list[low] = list[hight]; while(low &lt; hight &amp;&amp; list[low] &lt;= value) low++; list[hight] = list[low]; &#125; list[low] = value; return low;&#125; 实现方法不止一种，多思考 随机生成指定个数的数组函数1234567function getArray(num) &#123; let arr = []; for(let i = 0; i&lt; num; i++) &#123; arr.push(parseInt(Math.random() * 1000 + 1000)); &#125; return arr;&#125; 归并排序 含义 将两个或者两个以上的有序表组合成一个新的有序表 算法图示 12345678910111213141516171819202122232425function mergeSort(list) &#123; if(!Array.isArray(list)) throw new TypeError(&apos;list not Array&apos;) let mid = parseInt(list.length / 2) if(!mid) return list; return merge(mergeSort(list.slice(0, mid)), mergeSort(list.slice(mid)));&#125;function merge(left, right) &#123; let result = []; let i = 0; // left下标 let j = 0; // right下标 let len = left.length + right.length; // 总长度 for(; len; len--) &#123; if(i == left.length) &#123; result.push(right[j++]); &#125; else if(j == right.length) &#123; result.push(left[i++]); &#125; else if(left[i] &lt; right[j]) &#123; result.push(left[i++]); &#125; else &#123; result.push(right[j++]); &#125; &#125;return result;&#125; 基数排序1、链式基数排序性能对别 最后说明 参考文章前端的排序 图片是谷歌，如有侵权，请联系17051298278@163.com删除 引用本文章请注意注明出处。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构排序算法]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构（排序）标签（空格分隔）： 未分类 最近《数据结构（c语言）》课程结束，所以就想着整理一下《数据结构（c语言）》中的重点内容，因为我学习的是使用c语言进行实现，为了深入其中理解其中的过程，我计划使用ECMAScript实现其中的排序算法。 整体结构 插入排序1、直接插入排序123456789101112131415161718function insertSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr 不是数组&apos;); // 按照c语言方式，数组前推入一位作为监视哨 arr.unshift(undefined); console.time(&apos;插入排序耗时&apos;);for(let i = 2,length = arr.length; i &lt; length; i++) &#123; arr[0] = arr[i]; // 设置监视哨 if(arr[i-1] &gt; arr[i]) &#123; let j = i - 1; for(; arr[j]&gt;arr[0]; j--) &#123; arr[j+1] = arr[j]; // 记录后移 &#125; arr[j+1] = arr[0]; // 插入 &#125; &#125; console.timeEnd(&apos;插入排序耗时&apos;) return arr.slice(1);&#125; 2、折半插入（对直接插入的改进算法） 改进的主要内容在寻找插入位置的时候，使用折半算法，减少比较次数，然后常规移项，将节点插入 123456789101112131415161718192021222324function insertSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr 不是数组&apos;); // 按照c语言方式 arr.unshift(undefined); console.time(&apos;折半插入排序耗时&apos;); for(let i = 2,length = arr.length; i &lt; length; i++) &#123; let low = 1; let hight = i - 1; arr[0] = arr[i]; // 监视哨 // 和查找的折半算法不同，这一块找的是插入位置 while(low &lt;= hight) &#123; let m = parseInt((hight + low) / 2); if (arr[m]&lt;=arr[0]) low = m + 1; else hight = m - 1; &#125; for(let j = i-1; j &gt;= hight + 1; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[hight + 1] = arr[0]; &#125; console.timeEnd(&apos;折半插入排序耗时&apos;) return arr.slice(1);&#125; 3、希尔排序 出现原因 对于直接插入排序，其时间复杂度为O(n*n);但是，若待排序序列为“正序”时，其时间复杂度提升为O（n）。由此可以设想，当待排序列基本有序时，直接插入排序算法效率会大大提高。希尔排序正是从这两点分析出发，对直接排序算法改进得到的一种排序算法。 重要影响 1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 基本思想 先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，在对全体记录进行一次直接插入排序。 产生问题 就是这个增量该怎么选择？最简单的方法是第一轮排序的间隔为N/2，第二趟排序的间隔为N/4，依次类推。但是，实践证明，这种方法有时会使运行时间降到O(N2)，并不比插入排序的效率更高。保持间隔序列中的数字互质很重要，也就是说，除了1之外它们没有公约数。简单地取间隔为N/2，N/4，N/8…1时，没有遵循这一约束，所以使希尔排序的效率降低。 – &gt; 引用《算法（第四版）》 图示例（《数据结构（c语言）》） 123456789101112131415161718192021222324252627282930313233343536/** * * @param &#123;排序数组&#125; arr * @param &#123;间隔序列&#125; dk */function shellInsert(arr, dk) &#123; if(!Object.prototype.toString.call(arr).slice(8, -1) === &apos;Array&apos;) throw new TypeError(&apos;arr not Array&apos;); arr.unshift(undefined); // 用作暂存位 let length = arr.length; for(let i = dk + 1; i &lt; length; i++) &#123; if(arr[i] &lt;= arr[i - dk]) &#123; arr[0] = arr [i]; // 暂存位，注意和监视哨的区别 let j = i - dk; for(; j &gt; 0 &amp;&amp; arr[j] &gt;= arr[0]; j-=dk) &#123; arr[j + dk] = arr[j]; &#125; arr[j + dk] = arr[0]; &#125; &#125; return arr.slice(1);&#125;// 确定一个希尔排序间隔function insertSort(arr) &#123; let len = arr.length; let gap = 1; while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; console.time(&apos;希尔排序&apos;) for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; arr = shellInsert(arr, gap); &#125; console.timeEnd(&apos;希尔排序&apos;) return arr;&#125; 4、其他插入排序 2-路插入排序（p262 算法10.2） 表插入排序 （p268） 选择排序1、简单选择排序 123456789101112131415function selectSort(arr) &#123; console.time(&apos;选择排序&apos;); for(let i = 0,len = arr.length; i&lt;len; i++) &#123; let minKey = i; // 最小值 let minValue; for(let j = i+1; j &lt; len; j++) &#123; if(arr[j] &lt; arr[minKey]) minKey = j; &#125; minValue = arr[minKey]; arr[minKey] = arr[i]; arr[i] = minValue; &#125; console.timeEnd(&apos;选择排序&apos;) return arr;&#125; 2、堆排序 出现原因 在n个关键字中选择最小值，至少进行n-1次比较，然而，继续在剩余的n-1关键字中选择最小值就并非一定要进行n-2次比较,若是利用前面n-1次比较所得的信息，则可以减少以后选择排序所用的比较次数。则我们可以想到，必须有一个结构记录每次排序后的结果，所以这个结构我们称之为堆 堆的定义 基本思想 若在输出堆顶元素后，使得剩余的n-1个元素重新建成一个堆，则得到n个元素的次小值。如此反复执行。便能得到一个有序序列，这个过程称之为堆排序。 产生问题 ① 如何由一个无序序列构建成一个堆？② 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？我觉得我说不清这两个过程。p280参考，手动[滑稽] 图片参考 说明 测试了一下，我写的这个性能比较差， 感觉可能是因为使用递归的原因，后面在测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344function headAdjust(headData, headIndex) &#123; // headIndex以下变为堆 let headLeftIndex = 2 * headIndex; let headRightIndex = headLeftIndex + 1; let length = headData.length; let min = headIndex; // 最小节点 if(headLeftIndex &lt; length &amp;&amp; headData[headLeftIndex] &lt; headData[min]) min = headLeftIndex; if(headRightIndex &lt; length &amp;&amp; headData[headRightIndex] &lt; headData[min]) min = headRightIndex; // 进行替换 switch(min) &#123; case headLeftIndex: &#123; let temp = headData[headLeftIndex]; headData[headLeftIndex] = headData[headIndex]; headData[headIndex] = temp; headAdjust(headData, headLeftIndex); &#125;; break; case headRightIndex : &#123; let temp = headData[headRightIndex]; headData[headRightIndex] = headData[headIndex]; headData[headIndex] = temp; headAdjust(headData, headRightIndex); &#125;; break; default : break; &#125;&#125;function headSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr not Array&apos;); let headData = [undefined, ...arr]; // 使用顺序表存储 console.time(&apos;堆排序&apos;); // ①无序序列创建一个堆 for(let i = parseInt((headData.length-1) / 2); i &gt; 0; i--) &#123; headAdjust(headData, i); &#125; console.log(&apos;构造之后&apos;, headData); // ②输出堆顶元素调整剩余元素形成一个堆 for(let i = 1; headData.length !== 1; i++) &#123; arr[i-1] = headData[1]; // 取出当前 headData[1] = headData[headData.length-1]; // 将末尾的赋值给第一个 headData.length--; headAdjust(headData, 1); &#125; console.timeEnd(&apos;堆排序&apos;); return arr;&#125; 3、其他选择排序 树形选择排序 p277 交换排序1、 起泡排序（冒泡排序） 基本思想 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 图片参考 1234567891011121314function bubbleSort(arr) &#123; console.time(&apos;冒泡排序&apos;) for(let i = 0, len = arr.length; i &lt; len; i++) &#123; for(let j = len -1; j&gt;i; j--) &#123; if(arr[j - 1] &gt; arr[j]) &#123; let temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125; console.timeEnd(&apos;冒泡排序&apos;) return arr;&#125; 针对冒泡排序还有优化的方法（摘抄）具体戳十种排序算法 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 2、快速排序 基本思想 通过一趟排序将待排记录分为独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则分别对这两部分记录继续进行排序，以达到整个序列有序。 图示实例 p272 123456789101112131415161718192021222324252627function quickSort(arr) &#123; if(!Array.isArray(arr)) throw new TypeError(&apos;arr not Array&apos;); console.time(&apos;快速排序&apos;); function sort(list, low, hight) &#123; if(low &lt; hight) &#123; let pivotloc = partition(list, low, hight); sort(list, low, pivotloc - 1); sort(list, pivotloc + 1, hight); &#125; return list; &#125; const data = sort(arr, 0, arr.length-1); console.timeEnd(&apos;快速排序&apos;); return data;&#125;// 返回排序后的位置function partition(list, low, hight) &#123; let value = list[low]; while(low &lt; hight) &#123; while(low &lt; hight &amp;&amp; list[hight] &gt;= value) hight--; list[low] = list[hight]; while(low &lt; hight &amp;&amp; list[low] &lt;= value) low++; list[hight] = list[low]; &#125; list[low] = value; return low;&#125; 实现方法不止一种，多思考 随机生成指定个数的数组函数1234567function getArray(num) &#123; let arr = []; for(let i = 0; i&lt; num; i++) &#123; arr.push(parseInt(Math.random() * 1000 + 1000)); &#125; return arr;&#125; 归并排序 含义 将两个或者两个以上的有序表组合成一个新的有序表 算法图示 12345678910111213141516171819202122232425function mergeSort(list) &#123; if(!Array.isArray(list)) throw new TypeError(&apos;list not Array&apos;) let mid = parseInt(list.length / 2) if(!mid) return list; return merge(mergeSort(list.slice(0, mid)), mergeSort(list.slice(mid)));&#125;function merge(left, right) &#123; let result = []; let i = 0; // left下标 let j = 0; // right下标 let len = left.length + right.length; // 总长度 for(; len; len--) &#123; if(i == left.length) &#123; result.push(right[j++]); &#125; else if(j == right.length) &#123; result.push(left[i++]); &#125; else if(left[i] &lt; right[j]) &#123; result.push(left[i++]); &#125; else &#123; result.push(right[j++]); &#125; &#125;return result;&#125; 基数排序1、链式基数排序性能对别 最后说明 参考文章前端的排序 图片是谷歌，如有侵权，请联系17051298278@163.com删除 引用本文章请注意注明出处。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm介绍（一）]]></title>
    <url>%2F2018%2F04%2F07%2Fnpm%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、commonJS规范在介绍npm的前面，我们先介绍一下commonJS规范。commonJS规范的提出，主要是为了弥补js没有标准的缺陷，已达到Ruby和Java具备开发大型应用的基础能力，如今，commonJS中的大部分规范虽然依旧是草案，但是已经为javascript开发大型应用指明了一条非常棒方向，目前，它依然在成长，目前commonJS规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、web服务器网关接口、包管理等。而其中的npm则就是commonJS中关于包管理的具体实现。-摘抄于《深入浅出Nodejs》 二、npm基本介绍 Node组织了自身的核心模块，也使得第三方文件模块可以有序的编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和NPM则是将模块连接起来的一种机制。 模块就是：我们可以简单的把它看成一个实现单独功能的文件，模块和文件是一一对应的。 包：包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，它讲某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决包的发布和获取需求。包是由package.json定义的文件或目录 npm官方文档：https://docs.npmjs.com/ npm解决包的发布和获取需求 Node Package(包) Manager(管理器) 三、包结构与包描述文件1、commonJS规范中包结构 package.json： 包描述文件 bin：用于存放可执行二进制文件的目录 lib：用于存放JavaScript代码的目录 doc： 用于存放文档的目录 test： 用于存放单元测试用例的代码 2、commonJS 包描述文件CommonJS为package.json文件定义了如下一些必要字段 name:包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。 description：包的简要说明。 version: 符合语义化版本识别规范的版本字符串。 主版本号： 当API发生改变，并与之前的版本不兼容的时候 次版本号： 当增加了功能，但是向后兼容的时候 补丁版本号： 当做了向后兼容的缺陷修复的时候 keywords：关键字数组，通常用于搜索。 maintainers:维护者数组，每个元素要包含name、email（可选）、web（可选）字段。 contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。 bugs：提交bug的地址，可以是网址或者电子邮件地址。 licenses:许可证数组，每个元素要包含type(许可证的名称)和url(链接到许可证文本的地址)字段。 repositories：仓库托管地址数组。每个元素要包含type(许可证的名称)和url(链接到许可证文本的地址)字段。 dependencies:包的依赖，一个关联数组，由包名称和版本组成。 除此之外，还有一些可选字段： homepage： 当前包网站地址 os： 操作系统支持列表 cpu： cpu架构的支持列表 engine: 支持的JavaScript引擎类表，有效的引擎取值为ejs、flusspferd、node、v8等等 builtin： 标志当前包是否是内建在底层系统的标准组件 directories： 包目录说明 implements： 实现规范列表，标志当前包实现了commonJS的那些规范 script： 脚本说明对象。npm script 是记录在 package.json 中的 scripts 字段中的一些自定义脚本，使用自定义脚本，用户可以将一些项目中常用的命令行记录在 package.json 不需要每次都要敲一遍。 3、npm 包描述文件主要多了author、bin、main、devDependencies author： 包作者 bin： 一些包作者希望包可以作为命令行工具使用，配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。这种称之为全局模式 main： 模块引入方法require（）在引入包时，会优先检查这个字段，并将其作为包中其余模块入口。如果不存在这个字段，require（）方法会查找宝目录下的index.js、index.node、index.json文件作为默认入口 devDependencies: 一些模块只有在开发的时候需要依赖，配置这个属性，可以提示包的后续开发者安装依赖包。 四、依赖树概念 物理结构和逻辑结构 逻辑结构：npm ls以树状图的方式列下一个项目下面的所有依赖的 逻辑结构 物理结构：具体文件引用结构，通常有npm等包管理工具决定 问题：如果按照逻辑结构来决定物理结构，就会创建了太深的依赖关系树，导致 Windows 上很长的目录路径问题 五、模块查找方式（深入浅出Nodejs p16）1、三个步骤在node中引入一个模块需要经过三个步骤 路径分析 文件定位 编译执行 2、路径分析和文件定位 模块的分类： 核心模块 路径形式的文件模块 自定义模块 通常使用npm i安装的npm包都是自定义模块，在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相对来说比较慢，所以我们这里就什么理解自定义模块的查找方式中的路径生成规则，为什么你的require（包名）就能够将这个包require进来使用。 模块路径生成规则： 当前目录下的node_modules 父目录下的node_modules 父目录的父目录下node_modules 沿着路径向上逐级递归，直到根目录下的node_modules 可见当前文件目录越深，模块查找会耗时更多，这就是模块自定义加载速度是最慢的原因 六、安装依赖1、扁平化依赖 扁平化依赖 扁平化安装过程 2、模块安装过程npm v2解析包的依赖关系这个版本下安装依赖使用嵌套安装依赖 优点和弊端 优点：解决了版本单一时存在的不兼容问题，实现多版本兼容缺点：可能造成相同模块大量冗余 哪么如何做到多版本兼容额前提下减少这种模块冗余问题，于是npm3做了一个改进 npm v3解析包的依赖关系npm v3会尽量把逻辑上某个层级的模块在物理结构上全部放在项目的第一层级，具体摘抄为以下： 在安装某个二级模块的同时，如果发现第一层级层级还没有相同名称的模块，便把这第二层的模块放在第一层级（参考上满模块路径生成规则） 在安装某个二级模块的时，若发现第一层级有相同的名称，相同的版本，便直接复用那个模块 在安装某个二级模块时，若发现第一层级有相同名称，但是版本却不相同的模块，便只能嵌套在自身的父模块下方 但是npm v3仍然没有把npm v2模块冗余的缺陷优化到极致，可能出现这种情况 npm v3模块去重实际是使用 npm dedupe去除冗余模块原理就是当A模块下的C V1.0模块被更新到 C V2.0情况下，我们可以使用这条命令把所有C v2.0的二级依赖模块“重定向”到一级目录下的那个C v1.0 npm install发生了什么 官方安装文档 3、全局安装和局部安装按照位置来区分： 全局安装是安装在：/c/Users/用户名/AppData/Roaming/npm/node_modules 局部安装是安装在：当前项目的node_modules 按照使用方式： 全局安装：可以直接在命令行里面使用 局部安装：可以require（）引用使用 如何选择安装方式 如果您要在程序中使用的require(‘whatever’)，请使用本地安装，然后将其安装在项目的根目录下。 如果你正在安装你想在你的shell中使用的东西，在命令行或者其他东西上，请全局安装它，这样它的二进制文件最终会放到你的PATH环境变量中。 七、缓存目录 npm config get cache：查找缓存包存放地址 模块安装步骤： 发出npm install命令 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在npm-cache（缓存目录） 解压压缩包到当前项目的node_modules目录 运行npm install首先会判断项目文件夹node_modules中有没有对应的模块，没有直接去远程下载，然后保存在缓存中，将缓存中的压缩包解压至对应的项目的node_modules中。（不直接从缓存读取是因为缓存中的包版本可能是旧的，所以要去拉最新的包版本） 优先使用缓存安装：--prefer-offline 优先线上安装： --prefer-online 完全离线：--offline 八、npm缺陷 频繁使用的代码包创建了太深的依赖关系树，导致 Windows 上很长的目录路径问题（虽然v3版本使用扁平化算法进行优化。但是有时候也避免不了） 当被不同的依赖关系需要时，代码包会被复制粘贴多次，比较占存储空间 扁平化依赖树的算法相当复杂 不能保证同一份package.json在不同机器上安装着相同的依赖，可能间接导致错误（不可靠） 九、npx： 包执行器当升级npm@5.2.0，会安装一个新的包npx npx 的使用很简单，就是执行 npx command 即可，这里的 command 默认就是 ./node_modules 目录中安装的可执行脚本名。 了解很少，这篇博文讲的比较好npx介绍 十、常用命令 npm help &lt;????&gt;: 查看某一命令的帮助 npm install &lt;package&gt; ：默认使用–save，如果不想保存到package.json中，可以添加–no-save参数；还可以指定–save-dev 或 -g参数 npm install --production: npm将不会安装在中列出的模块 devDependencies npm install npm -g： npm更新命令 npm init：在此目录生成package.json文件，可以添加-y | –yes 参数则默认所有配置为默认yes npm root -g：查看全局安装地址 npm run:列出项目所有脚本命令参数， npm uninstall &lt;package&gt;:卸载依赖包， 默认使用–save参数，即从package.json中移除 npm ls [-g] [--depth=0]:查看当前目录或全局的依赖包，可指定层级为0 npm outdated：查看当前过期依赖，其中current显示当前安装版本，latest显示依赖包的最新版本，wanted显示我们可以升级到可以不破坏当前代码的版本 npm search &lt;string&gt;：查找包含该字符串的依赖包，根据keywords进行查找 npm prune：移除当前不在package.json中但是存在node_modules中的依赖 npm repo &lt;package&gt;：浏览器端打开项目地址（GitHub） npm home &lt;package&gt; ：在浏览器端查看项目（项目主页） npm info &lt;package&gt;: 查看package的package.json npm view &lt;package&gt;: 等同于npm info npm dedupe: 去除冗余模块 十一、学习资料 npm缓存目录 参考资料 package.json字段详解 深入模块的安装 2018年 你只会npm install吗？ npm与yarn缓存对比 为什么我不使用shrinkwrap（lock） pnpm介绍&lt;译文&gt; 三大包管理进行对比]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第四章 函数的扩展]]></title>
    <url>%2F2018%2F04%2F05%2Fes6%E6%B7%B1%E5%85%A5%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[相信明天会更好， 明天就会更好，早睡早起，健康生活 参数传值 参数默认值不是传值的，而是每次都重新计算默认值表达式的值，也就是说参数是惰性求值12345678let x = 99;function foo (p = x + 1) &#123; console.log(p);&#125;foo(); // 100x = 100;foo(); // 101 参数默认值位置 通常定义默认值的参数应该是函数的尾参数。因为这样能够看出省略了那些参数 如果传入undefined，将会默认触发该参数等于默认值，因为判断都是绝对等于undefined 函数的length属性 函数length的含义是：该函数预期传入的参数个数。某个参数指定默认值以后，后面的将不计算到length属性 作用域 参考https://segmentfault.com/a/1190000011900527 一旦设置参数的默认值，函数在进行生命初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失，这种语法行为在不设置参数默认值的时候不会出现的 在预解析阶段，会将所有的变量声明（只提升声明不提升赋值）以及函数声明（指整个函数），提升到其所在的作用域的最顶上，一般会先提升函数声明再提升变量声明。函数声明优先级高，但是函数和变量是不一样的，提升的优先级是函数比较高，但是实际运行过程中，只有变量才会重新赋值计算eg： 12345678910111213console.log(typeof f); // function，函数优先级高于变量声明var f;console.log(typeof f); // function,因为函数优先级高于变量声明var f = 5;console.log(typeof f); // number,因为上面对f进行赋值操作function f()&#123;&#125;;console.log(typeof f); // number， 相当与声明的语句只要在编译的时候有效 123456var x = 1;function foo(x =x) &#123; // ...&#125;// error报错，暂时性死区的影响 12345678910var x = 1;function foo(x, y = function() &#123; x = 2;&#125;) &#123; console.log(x); // undefined 被下面var a = 3覆盖 var x = 3; y(); console.log(x); // undefined console.log(x);&#125;foo(); // 3console.log(x); // 1 指定参数不能省略（利用参数惰性求值）123456function throwIfMissing() &#123; throw new Error(&apos;Missing parameter&apos;)&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided&#125; rest参数 替换argument参数 相比较而言： rest参数变量代表一个数组，所有数组特有的方法都可以用这个变量 rest参数之后不能再有其他参数，即只能是最后一个参数 严格模式在es6上面的修改 es6规定只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数内部就不能显示设定为严格模式，否则将会报错 这样规定的原因，就是函数内部的严格模式同时适用于函数体和函数参数。但是，函数执行时，先执行函数参数，然后在函数体，这样就有一个不合理的地方；只有从函数体之中才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行，但是此时参数相当于是语句。 两种方法解决这个问题 一种就是全局性的严格模式 把数包在一个无参数的立即执行函数里面 123456const daSomething = (function () &#123; &apos;use strict&apos;; return function (a = 5) &#123; console.log(a); &#125;&#125;)() name属性 返回函数的名称箭头函数 在箭头函数里面{} 被解释为代码块 不能当做构造函数，不可以使用new命令，因为没有自己的this 不可以使用argument对象，可以使用rest参数代替 不可以是使用yield命令，因此箭头函数不可以用作Generator函数 除了this，以下三个变量在箭头函数中也是不存在，分别指向外层函数的对应变量 argument super new.target 绑定this （ES7） 使用双冒号，左边一个对象，右边一个函数。该运算符会自动将左边对象做为上下文环境绑定到右边函数上 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上。 双冒号运算符返回的还是原对象 尾调用优化这是函数式编程的一个重要概念，本身十分简单，我们知道函数调用会在内存中形成一个‘调用记录’， 又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A内部调用函数B，那么在函数A的调用帧上方还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失，那么如果在B的内部调用函数C，那么将会有一个C的调用帧，以此类推，所有的调用帧将会形成一个调用栈（call stack）尾调用由于是函数的最后一步，所以不需要保留外层函数的调用帧，因为调用的位置、内部变量等信息都不会再用到了，直接用内层函数调用帧取代外层函数。做到每次执行的调用帧只有一项，这将大大节省内存，这就是尾调用优化的意义。 尾递归函数调用自身称之为递归，如果尾调用自身就称之为尾递归。 开启尾调用优化es6 尾调用优化只在严格模式下开启，正常模式下无效，这是因为在正常模式下函数内部有两个变量，可以跟踪函数的调用栈。 arguments： 返回调用时函数的参数 caller： 返回调用当前函数的那个函数 尾调用优化发生时，函数的调用栈将会被改写，因此上面两个变量就会失真，严格模式下禁用链两个变量，所以尾调用模式仅仅在严格模式下生效。 实现尾调用优化（正常模式下面实现）原理: 减少调用栈就不会发生溢出，使用循环代替递归 1234567// 蹦床函数(需要函数最后返回函数)function trampoline(f) &#123; while(f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 123456789101112131415161718192021// 真正的尾调用优化函数 （精华）function tco() &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;&#125;f.apply(this, accumulated.shift())返回的是sum(x+1,y+1);而sum = tco(func···),且此时active为true，所以函数返回undefined，但是却将参数传给accumulated，所以while在循环，直到结束，精巧]]></content>
      <categories>
        <category>es6 深入笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第三章 字符串扩展]]></title>
    <url>%2F2018%2F03%2F31%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[es6 加强了对unicode的支持，并且扩展了字符串对象，但是我对unicode不是很熟悉，也不是很感兴趣，所以本章主要记录字符串扩展后的对象的相关笔记 字符串的遍历器接口 es6为字符串添加了遍历器（Iterator）接口 。所有具有相关函数，比如第二章的解构赋值，后面的for of 循环 添加的方法 at() 等同于chatAt()，返回字符串给定位置的字符，不同的是at（）可以支持Unicode编号大于0xFFFF的字符 includes()、 startsWith()、endsWith() 返回的都是布尔值，表示是否包括、是否已什么开头、以什么结尾 都支持第二个参数，表示开始搜索的位置 repeat() 返回一个新字符串，表示将原字符串重复n次 如果参数是小数，则将会被向下取整 如果参数为负数或者Infinity，会报错 参数NaN等同于0 参数是字符串将会被先转换为数字 padStart()、padEnd() 如果字符串不够指定长度，会在头部和尾部补全、 接受两个参数，第一个用来指定字符串最小长度、第二个则是用来补全的字符串，默认为空格 如果补字符串和原字符串长度之和超过了指定的最小长度，则会截去超出他的补全字符串(都是截断后面) 模板字符串 如果使用模板字符串表示多行字符串，所有的空格和缩进都会保留在输出 ${ 可以放任意 表达式 } 标签模板 函数调用的特殊形式，标签指的就是函数，紧跟在后面的模板就是它的参数 12345const a = 15;const b = 50;tag `Hello $&#123; a +b &#125; world $&#123; a * b&#125; `;// 等同于调用tag函数tag( [&apos;Hello &apos;, &apos; world&apos;, &apos;&apos;],15, 50) 应用过滤HTML字符串 1234567891011121314const SaferHTML = (templateData, ...arguments) =&gt; &#123; var s = templateData[0]; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(s); var arg = String(arguments[i]); s += arg.replace(/&amp;/g, &apos;&amp;amp;&apos;) .replace(/&lt;/g, &apos;&amp;lt;&apos;) .replace(/&gt;/g, &apos;&amp;gt;&apos;) s += templateData[i+1]; &#125; return s;&#125;const formData = &quot;&lt;script&gt; alert(&apos;dingding&apos;) &lt;/script&gt;&quot;;SaferHTML `&lt;p&gt;$&#123;formData&#125;&lt;/p&gt;`]]></content>
      <categories>
        <category>es6 深入笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第二章 变量的解构赋值]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[重邮是我待过最美丽的地方 数组的解构赋值1234let [x, y, z] = [&apos;a&apos;];// x &apos;a&apos;// y undefined// z [] 数组的解构赋值的实质是指等号右边有iiterator 接口 可以在对应位留空来跳过被解构数组中的某些元素 默认值 es6 内部使用严格相等运算符（===）判断一个位置是不是有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的 1234let [ x = 1 ] = [ undefined ];// x = 1let [ x = 1 ] = [ null ]// x = null 因为null !== undefined 如果默认值是一个表达式，那么这个表达式是惰性求值的，只有在用到的时候才会调用 123let [ x = 1, y = x ] = []; // x = 1, y = 1;let [x = 1, y = x ] = [ 2 ] // x = 2, y =2;let [x = y, y = 1] = []; // ReferenceError 理解左边相当与声明，右边相当与赋值，如果右边有对应的，则优先于左边的默认值，否则，则左边相当与正常的变量声明,声明顺序按照左边的顺序 对象的解构赋值 内部机制： 先找到同名属性，然后在赋值给对应的变量，真正被赋值的是后者，而不是前者 1234let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, baz: &apos;bbb&apos; &#125;; // baz = &apos;aaa&apos;;// foo : error: foo is not defined// foo是匹配的模式，baz才是变量 注意分清模式与变量的区别 如果将一个已经声明的变量用于解构赋值，必须非常小心，、 1234let x; &#123; x &#125; = &#123; x:1 &#125;;// 这时候会报错，js引擎将之理解为一个代码块，只有不将大括号写在行首，避免js将其解释为代码块(&#123; x &#125; = &#123; x: 1 &#125;) 由于数组本质是太特殊的对象，因此也可以对数组进行对象属性的解构赋值 其他类型的解构赋值 因为字符串也具有Iterator接口，所以也可以进行解构赋 数值和布尔值将会被转化成对象 规则：只要等号右边的值不是对象或者数组，就将其转为对象。由于undefined和null无法转化为对象，所以对他们进行解构赋值时都会报错 函数的解构赋值123456let x = 10;function test(x, [y, z = x]) &#123; console.log(x, y, z);&#125;test(10, [5])// 10, 5, 10 1234567891011121314151617let x = 10;function test(x, [ y, x ]) &#123; console.log(x, y, z);&#125;test(10, [5])// SyntaxError: Duplicate parameter name not allowed in this context作用域*相当与:&#123; let x = 10; &#123; let x; let y; let x; console.log(x,y,z); &#125;&#125; 通过这个两个例子验证上文的理解圆括号问题 es6规则：只要可能导致解构的歧义，就不得使用圆括号 不可以使用圆括号 变量声明语句 函数参数（相当与变量声明） 赋值语句中模式 可以使用圆括号情况 赋值语句的非模式部分可以使用圆括号]]></content>
      <categories>
        <category>es6 深入笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一章 let and const]]></title>
    <url>%2F2018%2F03%2F31%2Fes6%E6%B7%B1%E5%85%A5%20%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[这个城市的辉煌，和你无关 for和function作用域区分 for循环的设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 function的参数区域和函数体属于一个作用域 function的参数区域的参数相当与使用let声明 1234567891011121314for (let i = 1;i&lt;2;i++) &#123; let i = &apos;abc&apos;; console.log(&apos;i =&apos;,i);&#125;// i = abc相当与：&#123; let i = 1; &#123; let i = &apos;abc&apos;; console.log(&apos;i =&apos;,i); &#125;&#125; 1234567891011function func (arg) &#123; let arg;&#125;func();// Uncaught SyntaxError: Identifier &apos;arg&apos; has already been declared相当与：&#123; let arg; let arg;&#125; 123456789101112131415function func(arg) &#123; &#123; let arg; &#125;&#125;func();// undefined相当与： &#123; let arg； &#123; let arg; &#125;&#125; 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就会绑定（binding）这个区域，不在受外部作用的影响 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，总之，在代码块内，使用let命令声明变量之前，改变量都是不可用的，这在语法上称之为“暂时性死区”（temploral dead zone, 简称TDZ） 1234567891011121314151617let y = 10;function bar (x = y, y = 2) &#123; return [x, y];&#125;bar();// SyntaxError: Identifier &apos;y&apos; has already been declared 相当与：&#123; let y = 10; &#123; let x = y; let y = 2; return [x, y]; &#125;&#125; 为什么需要块级作用域 内层变量可能会覆盖外层变量 用来计数的循环变量泄露为全局变量块级作用域与函数声明 ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能再块级作用域中声明。 ES6引入块级作用域，明确允许在块级作用域中声明函数。ES6规定，在块级作用域中，函数声明语句的行为类似于let，在块级作用域之外不可引用 但是为了减轻对ES5的不兼容问题，ES6在附录B中规定，浏览器的实现可以不遵守上面的规定，而有自己的行为方式，具体如下 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到作用域或函数作用域头部 同时，函数声明还会提升到所在的块级作用域的头部 123456789101112function f() &#123; console.log(&apos;I an outside!&apos;);&#125;(function ()&#123; if (false) &#123; function f() &#123;console.log(&apos;I an inside!&apos;)&#125; &#125; f();&#125;())// es5 环境 I an inside!// es6 环境 I an outside!// 浏览器环境 TypeError: f is not a function 1234567if (false) &#123; function f() &#123; console.log(&apos;I an outside&apos;); &#125;&#125;console.log(&apos;f&apos;, f);// f undefined 建议： 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式的形式，而不是函数声明 const 本质 实际上是保证的并不是变量的值不可以改动，而是变量指向的那个内存地址不得改动对象冻结12345678cosnt constantize = obj =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if(typeof obj[key] === &apos;object&apos;) &#123; constantize( obj[key] ); &#125; &#125;)&#125; 顶层对象属性顶层对象的属性与全局变量的赋值是同一回事，被认为是js的一大败笔 无法在编译时就提示变量未声明错误、只有在运行的时候才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的） 程序员很容易不知不觉就创造全局变量 顶层对象的属性是到处可以读写的，这非常不利于模块化编程 window对象有实体含义，指的是浏览器的窗口对象，这样也是不合适的。 ES6为了改变这一点 为了保持兼容性，var和function命令声明的全局变量依旧是顶层对象的属性 另一方面let命令、const命令、clas命令声明的全局变量不属于顶层对象的属性 global对象 浏览器中，顶层对象是window 浏览器和web worker中，self也指顶层对象 node中，顶层对象是global 在全局环境中，this返回顶层对象，在node和es6模块中，this返回当前模块 对于函数中的this，如果函数不是作为对象的方法运行，而是单纯的作为函数运行，this会指向顶层对象。但是，严格模式下，this会返回undefined 如何拿到顶层对象 方法一 123456(typeof window !== &apos;undefined&apos; ? window :(typeof process === &apos;object&apos; &amp;&amp; typeof require === &apos;function&apos; &amp;&amp; typeof global === &apos;object&apos;) ? global : this); 方法二 123456const getGlobal = () =&gt; &#123; if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125; if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125; if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125; throw new Error(&apos;unable to locate global object&apos;);&#125; 经典例子12345678910let arr = [];for(var i = 0; i &lt;6; i++)&#123; arr.push(function () &#123; console.log(i); i++; // 注意这里 &#125;);&#125;arr[0](); // =&gt;6arr[1](); // =&gt;7arr[2](); // =&gt;8 12345678910111213let arr = [];for(let i = 0; i &lt;6; i++)&#123; arr.push(function () &#123; console.log(i); i++; &#125;);&#125;arr[0]();arr[0](); // 注意这里输出1arr[1]();arr[2](); 1未完待续···]]></content>
      <categories>
        <category>es6 深入笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（二）]]></title>
    <url>%2F2018%2F03%2F28%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[真理惟一可靠的标准就是永远自相符合。 —— 欧文 这个模式旨在将方法调用、请求、操作封装到单一对象中去，从而根据我们不同的请求对客户进行参数化和传递可供执行的方法调用。Command模式背后主要思想是：他为我们提供了一种分离职责的手段，这些职责包括从执行命令的任意地方发布命令以及将该职责转而委托给不同的对象。12345678910111213141516171819202122var person = (function()&#123; var _name = &quot;&quot;; var _person = &#123; get: function(b)&#123; if(b===true)&#123; console.log(_name); &#125; return _name; &#125;, set:function(name)&#123; _name = name; &#125; &#125; var execute = function(name)&#123; return _person[name] &amp;&amp; _person[name].apply(_person,[].slice.call(arguments,1)) &#125; return &#123; &quot;execute&quot;:exexute &#125;;&#125;)();person.execute(&quot;set&quot;,&quot;ligen&quot;);person.execute(&apos;get&apos;,true); 如果将person里面的API更改了会怎么样，这就要求将里面所有的直接访问这些方法的对象都要进行更改，这被视作为一个耦合层，他实际上最大程度的违反了松散耦合对象的OOP方法论。而我们可以通过进一步抽象API来解决这个问题。所以产生execute函数，将方法调用集成在一个对象里，最大程度降低耦合性。 工厂模式这是一种创建型模式，涉及创建对象的概念。不同之处在于它不显示的要求使用一个构造函数。工厂模式可以提供一个通用的接口来创建对象。比如说：假设有一个UI工厂，我们需要初见创建一个UI组件的类型。不需要直接使用new运算符或者通过另一个创建型构造函数创建这个组件，而是要求Factory对象创建一个新的组件。我们通知Factory需要什么类型的对象（如按钮、面板），他会进行实例化，然后将它返回给我们使用。1234567891011121314151617181920212223242526272829303132function Car(options) &#123; this.doors = options.doors || 4; this.state = options.state || &quot;brand new&quot;; this.color = options.color || &quot;silver&quot;;&#125;function Trunk(options)&#123; this.state = options.state || &apos;used&apos;; this.wheelSize = options.wheelSize || &quot;large&quot;; this.color = options.color || &quot;blue&quot;;&#125;function Factory()&#123;&#125;Factory.prototype.vehicleClass = Car;Factory.prototype.createVerify = function(options)&#123; if(options.vehicleClass === &quot;car&quot;)&#123; this.vehicleClass = Car; &#125;else&#123; this.vehicleClass = Trunk; &#125; return new this.vehicleClass(options);&#125;var carFactory = new Factory();var car = carFactory.createVerify(&#123; vehicleClass:&quot;car&quot;, color:&quot;yellow&quot;, doors:6&#125;)console.log(car instanceof Car);console.log(carFactory);console.log(car); 当对象或组件设置涉及高复杂性 当需要根据所在的不同环境轻松生成对象的不同实例时 当处理很多共享相同属性的小型对象或组件时 在编写只需要满足一个API契约（亦称鸭子模型）的其他对象的实例对象时。对于解耦是很有用的。 Mixin模式在传统编程语言中，Mixin是可以轻松被一个子类或一组子类继承功能的类，目的是函数复用。在javascript中，我们可以将继承Mixin看做为一种通过扩展收集功能的方式。我们定义每个新对象都有一个原型，可以从中继承更多属性。原型可以继承于其他对象的原型。 123456789101112131415var Person = function(firstName,lastName)&#123; this.firstName = firstName; this.lastName = lastName; this.gender = &quot;male&quot;;&#125;;Person.prototype.getname =function () &#123; return this.firstName+this.lastName;&#125;var superhero = function(firstName,lastName,powers)&#123; Person.call(this,firstName,lastName); this.powers = powers;&#125;;superhero.prototype = Object.create(Person.prototype);//值得思考，为什么会有这一步var superman = superhero(&quot;li&quot;,&quot;gen&quot;,&quot;100&quot;)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（一）]]></title>
    <url>%2F2018%2F03%2F28%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[鸟欲高飞先振翅，人求上进先读书。——李苦禅 单例模式1234567891011121314function Universe() &#123; // 缓存的实例 var instance = this; // 其它内容 this.start_time = 0; this.bang = &quot;Big&quot;; // 重写构造函数 Universe = function () &#123; return instance; &#125;;&#125; 1234567891011121314151617181920212223242526function Universe() &#123; // 缓存实例 var instance; // 重新构造函数 Universe = function Universe() &#123; return instance; &#125;; // 后期处理原型属性 Universe.prototype = this; //可以理解下this是什么，直接调用时this是什么，并且重new机制来分析为什么，使用new指向函数对象本身【问题1】 // 实例 instance = new Universe(); // 重设构造函数指针 instance.constructor = Universe; // 其它功能 instance.start_time = 0; instance.bang = &quot;Big&quot;; return instance;&#125; 构造函数模式123//创建一个构造器函数，必须使用new来创建实例化吗？我们可以使用var a = new Object();构造函数.call(a，[参数]) 123456789101112//让构造函数强制使用new关键字function Car(model, year, miles) &#123; if (!(this instanceof Car)) &#123; return new Car(model, year, miles); &#125;//具体分析instance机制，并根据上面问题1来思考【问题2】 this.model = model; this.year = year; this.miles = miles; this.output = function () &#123; return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;; &#125;&#125; 建造者模式12 工厂模式12345678910111213141516//工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。var productManager = &#123;&#125;;productManager.createProductA = function () &#123; console.log(&apos;ProductA&apos;);&#125;productManager.createProductB = function () &#123; console.log(&apos;ProductB&apos;);&#125; productManager.factory = function (typeType) &#123; return new productManager[typeType];&#125;productManager.factory(&quot;createProductA&quot;); 装饰者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//装饰者通过重载的方法添加新功能，是一种实现继承的替代方案，在子类中正价行为会影响到原来类的所有实例，而装饰者却不然，取而代之的是它能够给不同对象各自添加/更改新行为。function baseClass() &#123; this.showPrice = function() &#123; console.log(&apos;基础价格: 100&apos;); &#125;&#125;// 装饰者1function decorator1(target) &#123; // 在装饰器内部保存对真实对象的引用 var instance = target; this.showPrice = function()&#123; // 这里是调用真实对象的引用 instance.showPrice(); // 这里是装饰器额外增加的代码 console.log(&apos;增加功能1之后的价格：899&apos;); &#125;&#125;// 装饰者2function decorator2(target) &#123; var instance = target; this.showPrice = function() &#123; instance.showPrice(); console.log(&apos;增加功能2之后的价格：1999&apos;); &#125;&#125;var baseInstance = new baseClass();//装饰器的参数可以是baseClass实例，也可以是其他装饰器实例var decorator_1 = new decorator1(baseInstance);// 到这来只给baseClass增加了decorator1decorator_1.showPrice();var decorator_2 = new decorator2(decorator_1);//var decorator_2 = new decorator2(baseInstance);decorator_2.showPrice();console.log(&apos;这个是链式操作的装饰者模式&apos;);var decorator_2_1 = new decorator2(new decorator1(baseInstance));decorator_2_1.showPrice();//装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。优点是把类（函数）的核心职责和装饰功能区分开了。 外观模式外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。 代理模式为其他对象提供一种代理以控制对这个对象的访问1234567891011121314151617181920212223// 先声明美女对象var girl = function (name) &#123; this.name = name;&#125;;// 这是duduvar dudu = function (girl) &#123; this.girl = girl; this.sendGift = function (gift) &#123; alert(&quot;Hi &quot; + girl.name + &quot;, dudu送你一个礼物：&quot; + gift); &#125;&#125;;// 大叔是代理var proxyTom = function (girl) &#123; this.girl = girl; this.sendGift = function (gift) &#123; (new dudu(girl)).sendGift(gift); // 替dudu送花咯 &#125;&#125;;var proxy = new proxyTom(new girl(&quot;酸奶小妹&quot;));proxy.sendGift(&quot;999朵玫瑰&quot;); 观察者模式12345678910111213141516171819202122232425262728293031//通用代码var observer = &#123; //订阅 addSubscriber: function (callback) &#123; this.subscribers[this.subscribers.length] = callback; &#125;, //退订 removeSubscriber: function (callback) &#123; for (var i = 0; i &lt; this.subscribers.length; i++) &#123; if (this.subscribers[i] === callback) &#123; delete (this.subscribers[i]); &#125; &#125; &#125;, //发布 publish: function (what) &#123; for (var i = 0; i &lt; this.subscribers.length; i++) &#123; if (typeof this.subscribers[i] === &apos;function&apos;) &#123; this.subscribers[i](what); &#125; &#125; &#125;, // 将对象o具有观察者功能 make: function (o) &#123; for (var i in this) &#123; o[i] = this[i]; o.subscribers = [];//让每一个对象都有自己的观察者 &#125; &#125;&#125;;//总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。 策略模式33 命令模式1234567891011121314151617181920212223242526272829(function () &#123; var CarManager = &#123; // 请求信息 requestInfo: function (model, id) &#123; return &apos;The information for &apos; + model + &apos; with ID &apos; + id + &apos; is foobar&apos;; &#125;, // 购买汽车 buyVehicle: function (model, id) &#123; return &apos;You have successfully purchased Item &apos; + id + &apos;, a &apos; + model; &#125;, // 组织view arrangeViewing: function (model, id) &#123; return &apos;You have successfully booked a viewing of &apos; + model + &apos; ( &apos; + id + &apos; ) &apos;; &#125; &#125;; CarManager.execute = function (command) &#123; return CarManager[command.request](command.model, command.carID); &#125;; CarManager.execute(&#123;&quot;request&quot;:&quot;buyVehicle&quot;,&quot;model&quot;:&quot;car&quot;,&quot;carID&quot;:&quot;552&quot;&#125;);&#125;)();//命令模式(Command)的定义是：用于将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理 迭代器模式1234567891011121314151617181920212223242526272829303132333435var agg = (function () &#123; var index = 0, data = [1, 2, 3, 4, 5], length = data.length; return &#123; next: function () &#123; var element; if (!this.hasNext()) &#123; return null; &#125; element = data[index]; console.log(element) index = index + 1; return element; &#125;, hasNext: function () &#123; return index &lt; length; &#125;, rewind: function () &#123; index = 0; &#125;, current: function () &#123; return data[index]; &#125; &#125;;&#125; ());while(agg.hasNext())&#123; agg.next();&#125; 中介者模式用来解决多个对象之间的通信123456789101112131415161718192021222324252627282930var mediator = (function () &#123; // 订阅一个事件，并且提供一个事件触发以后的回调函数 var subscribe = function (channel, fn) &#123; if (!mediator.channels[channel]) mediator.channels[channel] = []; mediator.channels[channel].push(&#123; context: this, callback: fn &#125;); return this; &#125;, // 广播事件 publish = function (channel) &#123; if (!mediator.channels[channel]) return false; var args = Array.prototype.slice.call(arguments, 1); for (var i = 0, l = mediator.channels[channel].length; i &lt; l; i++) &#123; var subscription = mediator.channels[channel][i]; subscription.callback.apply(subscription.context, args); &#125; return this; &#125;; return &#123; channels: &#123;&#125;, publish: publish, subscribe: subscribe, installTo: function (obj) &#123; obj.subscribe = subscribe; obj.publish = publish; &#125; &#125;;&#125; ()); 享元模式12 职责链模式职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理这个请求为止 也就是说，请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——也就是该请求有一个隐式的接受者（implicit receiver）。根据运行时刻，任一候选者都可以响应相应的请求，候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。 使用javascript中原型链机制实现,联想node中express框架中间件123456789101112131415161718192021222324252627var NO_TOPIC = -1;var Topic;function Handler(s, t) &#123; this.successor = s || null; this.topic = t || 0;&#125;Handler.prototype = &#123; handle: function () &#123; if (this.successor) &#123; this.successor.handle() &#125; &#125;, has: function () &#123; return this.topic != NO_TOPIC; &#125;&#125;var app = new Handler(&#123;handle:function()&#123; console.log(&quot;最后一层执行&quot;)&#125;&#125;,3);var dialog = new Handler(app,1);var button = new Handler(dialog,2);button.handle(); 如何调用时让dialog这个对象进行处理？12345只需要定义dialog.handle的方法就可以阻断eg：dialog.handle = function()&#123; console.log(&quot;进行阻断&quot;);&#125; 那能不能让dialog处理完以后，让继任者继续进行处理？1调用Handle.prototype.handle.call(this); 适配器模式组合模式组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 常见的DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。 123具体实例：www.cnblogs.com/TomXu/archive/2012/04/12/2435530.html 模板方法模板方法（TemplateMethod）定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现 各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码 控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展1234567891011121314151617181920212223242526272829303132333435363738394041//举个例子，泡茶和泡咖啡有同样的步骤，比如烧开水（boilWater）、冲泡（brew）、倒在杯子里（pourOnCup），加小料（addCondiments）等等。但每种饮料冲泡的方法以及所加的小料不一样，所以我们可以利用模板方法实现这个主要步骤。var Student = function()&#123;&#125;;//将学生们统一过程放在原型链中Student.prototype.begin = function()&#123; this.getUp(); this.wash(); if(this.needClass())&#123; this.goToClass(); &#125;&#125;Student.prototype.getUp = function()&#123; console.log(&quot;我起床了！&quot;)&#125;Student.prototype.wash = function()&#123; console.log(&quot;完成洗漱！&quot;)&#125;//这两个进行判断和执行上课特殊步骤Student.prototype.needClass = function () &#123; return false; //默认今天要上课&#125;Student.prototype.goToClass = function()&#123; throw Error(&quot;这个方法需要重写！&quot;);&#125;//619寝室的学生类var Student619 = function(name)&#123; Student.apply(this); this.name = name;&#125;Student619.prototype = new Student();Student619.prototype.needClass = function()&#123; return true;&#125;Student619.prototype.goToClass = function()&#123; console.log(this.name+&quot;去上课&quot;);&#125;//619宿舍中的学生实例var ligen = new Student619(&quot;ligen&quot;);ligen.begin(); 原型模式主要是Object.create()机制和原型链理解 12345678var a = &#123; name : &quot;ligen&quot;, age : 35&#125;var b = Object.create(a);console.log(b.__proto__)//让b的隐式原型指向a 状态模式状态模式（State）允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类。 桥接模式桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 代码复用模式（避免篇） 借助构造函数并且设置原型123456789101112131415161718// 父构造函数function Parent(name) &#123; this.name = name || &apos;Adam&apos;;&#125;// 给原型添加say功能Parent.prototype.say = function () &#123; return this.name;&#125;;// Child构造函数function Child(name) &#123; Parent.apply(this, arguments);&#125;Child.prototype = new Parent();运行起来一切正常，但是Parent构造函数运行了两次，效率很低。这种比较符合思维 代码复用（推荐篇）在 JavaScript 里使用 typeof 来判断数据类型，只能区分基本类型，即 “number”，”string”，”undefined”，”boolean”，”object” 五种。 对于数组、函数、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 字符串。 要想区别对象、数组、函数单纯使用 typeof 是不行的，JavaScript中,通过Object.prototype.toString方法，判断某个对象值属于哪种内置类型。 深拷贝 123456789101112131415161718192021222324252627282930313233/* 浅拷贝 */function extend(parent, child) &#123; var i; child = child || &#123;&#125;; for (i in parent) &#123; if (parent.hasOwnProperty(i)) &#123; child[i] = parent[i]; &#125; &#125; return child;&#125;/* 深拷贝 */循环迭代进行深赋值function extendDeep(parent, child) &#123; var i, toStr = Object.prototype.toString, astr = &quot;[object Array]&quot;; child = child || &#123;&#125;; for (i in parent) &#123; if (parent.hasOwnProperty(i)) &#123; if (typeof parent[i] === &apos;object&apos;) &#123; child[i] = (toStr.call(parent[i]) === astr) ? [] : &#123;&#125;; extendDeep(parent[i], child[i]); &#125; else &#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125; 混合（mix-in） 混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象 123456789101112function mix() &#123; var arg, prop, child = &#123;&#125;; for (arg = 0; arg &lt; arguments.length; arg += 1) &#123; for (prop in arguments[arg]) &#123; if (arguments[arg].hasOwnProperty(prop)) &#123; child[prop] = arguments[arg][prop]; &#125; &#125; &#125; return child;&#125;//mix函数将所传入的所有参数的子属性都复制到child对象里，以便产生一个新对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Carvar Car = function (settings) &#123; this.model = settings.model || &apos;no model provided&apos;; this.colour = settings.colour || &apos;no colour provided&apos;;&#125;;// Mixinvar Mixin = function () &#123; &#125;;Mixin.prototype = &#123; driveForward: function () &#123; // console.log(&apos;drive forward&apos;); &#125;, driveBackward: function () &#123; // console.log(&apos;drive backward&apos;); &#125;&#125;;// 定义的2个参数分别是被混入的对象（reciving）和从哪里混入的对象（giving)function augment(receivingObj, givingObj) &#123; // 如果提供了指定的方法名称的话，也就是参数多余3个 if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; receivingObj.prototype[arguments[i]] = givingObj.prototype[arguments[i]]; &#125; &#125; // 如果不指定第3个参数，或者更多参数，就混入所有的方法 else &#123; for (var methodName in givingObj.prototype) &#123; // 检查receiving对象内部不包含要混入的名字，如何包含就不混入了 if (!receivingObj.prototype[methodName]) &#123; receivingObj.prototype[methodName] = givingObj.prototype[methodName]; &#125; &#125; &#125;&#125;// 给Car混入属性，但是值混入&apos;driveForward&apos; 和 &apos;driveBackward&apos;*/augment(Car, Mixin, &apos;driveForward&apos;, &apos;driveBackward&apos;);// 创建新对象Carvar vehicle = new Car(&#123; model: &apos;Ford Escort&apos;, colour: &apos;blue&apos; &#125;);// 测试是否成功得到混入的方法vehicle.driveForward();vehicle.driveBackward();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[定位问题]]></title>
    <url>%2F2017%2F05%2F16%2F%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[定位问题 本文引用地址大漠老师主讲定位详解 博客园position/float详细 常见两列布局 ####Overflow技巧一种清除浮动的技巧是使用“overflow”属性。在具有浮动元素的父容器中设置“overflow”的属性值为“auto| | hidden”，这样父容器就会有一个高度存在。1234567891011121314/* 默认值。内容不会被修剪，会呈现在元素框之外 */overflow: visible;/* 内容会被修剪，并且其余内容不可见 */overflow: hidden;/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */overflow: scroll;/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */overflow: auto;/* 规定从父元素继承overflow属性的值 */overflow: inherit; 为什么overflow：hidden || auto 会撑起父div因为overflow.hidden会触发BFC。 BFC的意思是，我这个元素里面的子孙元素，不会影响外部元素的布局。但浮动本身会造成行内宽度的压缩，出现文字环绕效果。如此一来，浮动元素越宽，当然行内的可容纳的文字数就越少，文字的行数就会增加，文档流高度也就增加。这样，就影响了其外部元素的布局。所以从BFC的本意来说，必须给浮动元素撑出高度，使得后续的元素无法跟浮动元素共享同一水平位置，看上去就是 clear both 的效果了。 BFC三个特性 BFC会阻止垂直外边距（margin-top、margin-bottom）折叠按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了。 BFC不会重叠浮动元素 BFC可以包含浮动 我们可以利用BFC的第三条特性来“清浮动”，这里其实说清浮动已经不再合适，应该说包含浮动。也就是说只要父容器形成BFC就可以， 简单看看父容器如何形成BFC float为 left|right overflow为 hidden|auto|scroll display为 table-cell|table-caption|inline-block position为 absolute|fixed verflow属性会影响滚动条和绝对定位的元素；position会改变元素的定位方式，这是我们不希望的，display这几种方式依然没有解决低版本IE问题。。。看起来还是第一种方式比较好，可是低版本IE该怎么办呢？ IE6、7方法：我们知道在IE6、7内有个hasLayout的概念，很多bug正式由hasLayout导致的，当元素的hasLayout属性值为false的时候，元素的尺寸和位置由最近拥有布局的祖先元素控制。当元素的hasLayout属性值为true的时候会达到和BFC类似的效果，元素负责本身及其子元素的尺寸设置和定位。我们可以利用这点儿在IE6、7下完成清浮动，先看看怎么使元素hasLayout为true position: absolute float: left|right display: inline-block width: 除 “auto” 外的任意值 height: 除 “auto” 外的任意值 zoom: 除 “normal” 外的任意值 writing-mode: tb-rl 在IE7中使用overflow: hidden|scroll|auto 也可以使hasLayout为true####clearfix技巧“clearfix”技巧是基于在父元素上使用“:before”和“:after”两个伪类。使用这些伪类，我们可以在浮动元素的父容器前面和后面创建隐藏元素。“:before”伪类是用来防止子元素顶部的外边距塌陷，使用“display:table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪类是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。 在IE6和7的浏览器中，加上“*zoom”属性来触发父元素的hasLayout的机制。决定了元素怎样渲染内容，以及元素与元素之间的相互影响。 采取上面同样的例子，你可以看到容器也清除了浮动，元素也可以移到父容器外面： 第一种123456789.clearfix:after &#123; content: " "; display: block; clear: both; height: 0;&#125;.clearfix &#123; zoom: 1;&#125; 原理：标准浏览器下，.clearfix:after这个伪类会在应用到.clearfix的元素后面插入一个clear: both的块级元素，从而达到清除浮动的作用弊端：很可能清除不必要的浮动 第二种（终极版本）1234567891011.box-set:before,.box-set:after&#123;content:"";display:table;&#125;.box-set:after &#123;clear:both;&#125;.box-set &#123;*zoom:1;/*IE/7/6*/&#125; 第三种(不属于清除浮动，但是某些时候也可以采用这种方法进行排版)属于上面让父元素形成BFC 123.items &#123; display:inline-block;&#125; 原理：标准浏览器下，.clearfix:after这个伪类会在应用到.clearfix的元素后面插入一个clear: both的块级元素，从而达到清除浮动的作用弊端：解决上面的弊端，原因暂时看不懂。以后深究。目前每个元素只有一组after和before，所以在使用了clearfix之后不能够在使用after和before ####邻接元素清理 原理就是在这个元素加个clear：both或者给他的after（可能产生的隐藏溢出元素问题） ####其他的方法 &lt;br clear:both&gt; &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;* ####定位属性 #####Position static 元素都有position属性，默认值是static，这也就意味着如果不设置元素position属性，那么（left、right、top、bottom）都将不起作用 #####Position relative设置了位移属性的相对定位元素，他在页面中仍然是正常的、静态的，仍属于自然流。在这种情况下，其他元素不会占用相对定们元素当初的位置。此外，其他元素没有进行位置移动时，相对定伴元素可能会和其他元素重叠。 （每个元素还是在另一个元素顶部，然后他们根据自己移位属性，从默认位置进行移动，由于他们移向方向不一样，这些值使元素重叠在一起。当元素设置了相对定时，周边的元素也能看到相对定位元素的默认位置。（也就是说，相对定位元素的默认位置还是被元素自身占用，别的元素是无法占用的。也就是说相对定位元素的位移是相对于元素自身的边缘进行位移） ####position absolute绝对定位元素也具有盒子位移属性，然而，绝对定位元素会脱离文档流。绝对定位元素直接从文档流中移出，绝对定位元素的位置直接和父容器是否设置了相对定位（绝对定位）有直接关系。绝对定位元素需要至少一个祖先元素设置了相对定位（绝对定位），不然元素定位会相对于页面的主体进行定位。 使用绝对定位的元素可以指定垂直和水平的位移属性，使绝对定位元素相对于设置了相对定们的祖先元素边缘进行移位。 块状元素在position(relative/static)的情况下width为100%，但是设置了position: absolute之后，会将width变成auto（会受到父元素的宽度影响）。 元素设置了position: absolute之后，如果没有设置top、bottom、left、right属性的话，浏览器会默认设置成auto，而auto的值则是该元素的“默认位置”。即设置position: absolute前后的offsetTop和offsetLeft属性值不变。 应用了position: relative/absolute的元素，margin属性仍然有效，以position:relative来举例。如果设置了left、top、bottom、right的属性，建议大家不要设置margin数据，因为很难精确元素的定位，尽量减少干扰因素。 position: absolute忽略根元素的padding。 在IE6/7中设置position属性后会导致z-index属性失效 行内元素在应用了position：absolute之后会改变display。 应用了position: absolute / relative之后，会覆盖其他非定位元素（即position为static的元素），如果你不想覆盖到其他元素，设置z-index； ####position fixed 会改变行内元素的呈现模式，使display之变更为block。 会让元素脱离普通流，不占据空间。 默认会覆盖到非定位元素上。 fixed与absolute最大的区别在于：absolute的”根元素“是可以被设置的，而fixed则其”根元素“固定为浏览器窗口。即当你滚动网页，其元素与浏览器窗口之间的距离是恒定不变的。 ####position float 元素同时应用了position: absolute及float属性，则float失效。 第一个元素应用了position之后会覆盖着接下来的float元素（如果两个元素所处的位置相同）123456&lt;div style="position: absolute; left:10px; top: 10px;"&gt; 我是一个应用了position：absolute的DIV。&lt;/div&gt;&lt;div style="float:left; background: red; width: 300px; height: 150px; "&gt; 我是float：left的DIV&lt;/div&gt; bug..下面这个div的position也将会变成abslute]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float]]></title>
    <url>%2F2017%2F05%2F16%2Ffloat%2F</url>
    <content type="text"><![CDATA[####常见的float布局及其原理分析CSS position属性进行布局，或者使用CSSfloat属性布局。前者适合布局首页，因为首页上的内容往往可以完全控制。后者适合布局模板，模板中填充的内容你没法控制在实践过程中，领悟到一点，那就是，div是按照在HTML文档中的顺序进行渲染的。也就是说，我们先决定前一个div在页面上的位置，然后再决定后一个div的位置。也许这一点是显而易见的，但它确实是理解Float布局的关键 当一个元素具有float属性时，浏览器会怎样做？我想是这样的： 渲浏览器探测到这个元素具有float:right属性， 根据其内容限制了div的宽度（而不是尽量占满父元素宽度） 脱离文档流，并选择这样的位置进行渲染： 首先要在文档流没有占领的区域，否则就有可能覆盖已经渲染的文档。 其次，也没有其他float元素。 最后，渲染之后不会影响文档流。文档流该怎么走还怎么走，但是文档中的内容会自动绕开float元素。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; #header&#123;background-color: gray;&#125; #content&#123;background-color: red;&#125; #sidebar&#123;background-color: blue;&#125; #sidebar2&#123;background-color: green;&#125; #footer&#123;background-color: yellow;&#125; #sidebar&#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="page"&gt; &lt;div id="header"&gt;&lt;h1&gt;这里是标题&lt;/h1&gt;&lt;/div&gt; &lt;div id="sidebar2"&gt; &lt;p&gt;侧边栏2：地图投影，是将地球表面投影到地图平面的过程，将地理坐标转换为平面直角坐 标的过程。因为毕业论文需要，我重新回顾了一下地图投影的知识并且作了比较全面且简洁的总 结。如果你之前未系统了解过地图投影，又对地图投影感兴趣，这篇博文也许能成为一篇简洁务 实的阅读材料。&lt;/p&gt; &lt;/div&gt; &lt;div id="sidebar"&gt; &lt;p&gt;侧边栏&lt;/p&gt; &lt;/div&gt; &lt;div id="content"&gt; &lt;p&gt;这里是一些文字&lt;/P&gt; &lt;p&gt;再来一大段文字&lt;/P&gt; &lt;p&gt;地图投影，是将地球表面投影到地图平面的过程，将地理坐标转换为平面直角坐标的过程。 因为毕业论文需要，我重新回顾了一下地图投影的知识并且作了比较全面且简洁的总结。如果你 之前未系统了解过地图投影，又对地图投影感兴趣，这篇博文也许能成为一篇简洁务实的阅读材 料。&lt;/p&gt; &lt;/div&gt; &lt;div id="footer"&gt;&lt;p&gt;没人关注的页脚&lt;/P&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 交换浮动的元素位置，观察页面是怎么样渲染的 浮动和负边距实现左边固定右边自适应12345678910111213141516171819202122232425262728293031html: &lt;div id="left"&gt; Left Sidebar &lt;/div&gt; &lt;div id="content"&gt; &lt;div id="contentInner"&gt; Main Content &lt;/div&gt; &lt;/div&gt;css: *&#123; margin: 0; padding: 0; &#125; #left &#123; background-color: green; float: left; width: 220px; margin-right: -100%;//设置自己右边的元素向左移动100% &#125; #content &#123; float: left; width: 100%; &#125; #contentInner &#123; margin-left: 220px;/*==等于左边栏宽度值==*/ background-color: orange; &#125; 左右两列固定，中间自适应宽度 原理：让左右两列脱离文档流position：absolute；设置左右两列宽度，然后让中间宽度为100%，然后设置中间的margin，预留出左右两列的宽度；这种布局简单，但是也是麻烦最多的，如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。 原理：浮动原理，左右定宽度分别进行左浮动和右浮动，此时主内容列（中间列没有定度）主会自动插入到左右两列的中间，最要注意的一点是，中间列一定要放在左右两列的后面。 原理：使用负的margin； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; #main &#123; float: left; width: 100%; &#125; #mainContainer &#123; margin: 0 230px; height: 200px; background: green; &#125; #left &#123; float: left; margin-left: -100%; //左栏固定在屏幕最右边 width: 230px; &#125; #right &#123; float: left; margin-left: -230px; //右栏固定在屏幕最右边，相当与将这个元素向左走，等于宽度时会跳到上一行 width: 230px; &#125; #left .inner, #right .inner &#123; background: orange; margin: 0 10px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div id="mainContainer"&gt;main content&lt;/div&gt; &lt;/div&gt; &lt;div id="left"&gt; &lt;div id="leftContainer" class="inner"&gt;left content&lt;/div&gt; &lt;/div&gt; &lt;div id="right"&gt; &lt;div id="rightContainer" class="inner"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 学习上面代码时可以将margin变下感受margin在此处的作用中间固定，两边自适应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; #main &#123; float: left; width: 500px; z-index:1; &#125; #mainContainer &#123; background-color: blue; height:200px; &#125; #left &#123; float: left; margin: 0 0 0 -271px; width: 50%; z-index:-1; &#125; #right &#123; float: left; margin-right:-271px; width: 50%; opacity:.5; z-index:-1; &#125; #left .inner&#123; background: orange; margin: 0 10px; height: 250px; &#125; #right .inner &#123; background: red; margin: 0 10px; height: 250px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="left"&gt; &lt;div id="leftContainer" class="inner"&gt;left content&lt;/div&gt; &lt;/div&gt; &lt;div id="main"&gt; &lt;div id="mainContainer"&gt;main content&lt;/div&gt; &lt;/div&gt; &lt;div id="right"&gt; &lt;div id="rightContainer" class="inner"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 原理相同，让左边的那个元素通过margin向左走250px；让右边的那个元素向右走250px；但是他们两个宽度都是50%，所以中间会固定有500px的空白区域，在排版时注意要将移动的宽度通过inner清除 等高布局 第一种实现12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; html &#123; height: auto; &#125; body &#123; margin: 0; padding: 0; &#125; #container &#123; background: #ffe3a6; &#125; #wrapper &#123; display: inline-block; //清除浮动，激发BFC border-left: 200px solid #d4c376;/*==此值等于左边栏的宽度值==*/ position: relative; vertical-align: bottom; &#125; #sidebar &#123; float: left; width: 200px; margin-left: -200px;/*==此值等于左边栏的宽度值==*/ position: relative; &#125; #main &#123; float: left; &#125; #maing, #sidebar&#123; min-height: 200px; height: auto !important;//高度自适应，主要的是，!important只是对于ie6不认识而已，其他 //浏览器都是以这个为最高的优先级 height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt; &lt;div id="wrapper"&gt; &lt;div id="sidebar"&gt;Left Sidebar&lt;/div&gt; &lt;div id="main"&gt;Main Content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 原理：设置wrapper宽度100%，一个左边框宽度等于等会设置的sidebar宽度，将sidebar浮动向左通过margin-left向左平移到刚才wrapper左边框的位置，设置main宽度100%，浮动，然后就模拟成等高，真实是sidebar的高度没有那么高，由wrapper的边框背景来模拟高度；好处是不影响下面的排版。 第二种实现方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; *&#123;padding: 0;margin: 0;&#125; #container1 &#123; float: left; width: 100%; background-color: #dbddbb; &#125; #container &#123; background-color: orange; width: 100%; overflow:hidden; position: relative; left: 220px;/* 宽度大小等与边栏宽度大小*/ &#125; #left &#123; float: left; margin-right: -100%; margin-left: -220px;/* 宽度大小等与边栏宽度大小*/ width: 220px; &#125;//让左边的出去到刚才containter left的位置 #content &#123; float: left; width: 100%; margin-left: -220px;/* 宽度大小等与边栏宽度大小*/ //这一行的意义在于下面contentInner设置了margin-left：220px； &#125; #contentInner &#123; margin-left: 220px;/* 宽度大小等与边栏宽度大小*/ overflow: hidden; &#125; #left, #content &#123; min-height: 200px; height: auto !important; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;div id="container1"&gt; &lt;div id="container"&gt; &lt;div id="left"&gt;Left Sidebar&lt;/div&gt; &lt;div id="content"&gt; &lt;div id="contentInner"&gt;Main Content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 原理： ####float布局的常见问题解决 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;style&gt;.panel &#123; border:1px solid green; height:200px;&#125;.panel div &#123; font:14px/100px 微软雅黑; text-align:center; width:100px;height:100px; border:1px solid red; margin:10px; /*左浮动*/ float:left;&#125;&lt;/style&gt;&lt;div class="panel"&gt; &lt;div&gt;次碳酸钴&lt;/div&gt; &lt;div&gt;次碳酸钴&lt;/div&gt;&lt;/div&gt;&lt;script&gt; 在IE6下还要做个BUG修正，因为在IE6有双倍的margin的bug，这个例子中使用了margin，所以在IE6下显示不正常 例子中的元素是float:left，第一个元素与左边容器壁接触，所以原来的margin-left是10px，在IE6下就变成了20px。 解决这个问题可以把第一个浮动元素变成inline-block。但是IE对inline-block的支持本身就很奇怪，IE6下的block元素不能直接设置inline-block，需要先inline，再添加hasLayout。而float这个属性的添加，便会给元素带去hasLayout。所以，IE6下只要对浮动的元素添加display:inline就可以了。针对IE6可以使用CSS hack完成。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .boxs&#123; border:1px solid blue; float:left; //浮动元素父元素也设置float会清除浮动 &#125; /* .boxs:after &#123; content:""; display:table; clear:both; &#125; */ .items &#123; border:1px solid red; width:100px; height:100px; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="boxs"&gt; &lt;div class="items"&gt;&lt;/div&gt; &lt;div class="items"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ![图片][1]（浮动元素嵌套浮动元素）清除浮动的时候会有IE6.7会有显得问题产生问题：当容器元素浮动时，内部浮动元素的margin-bottom不会起作用，解决这个问题，通常用容器的padding-bottom代替 内部浮动元素的margin-bottom]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
